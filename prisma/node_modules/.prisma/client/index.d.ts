
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Account
 * 
 */
export type Account = {
  id: string
  userId: string
  type: string
  provider: string
  providerAccountId: string
  refresh_token: string | null
  access_token: string | null
  expires_at: number | null
  token_type: string | null
  scope: string | null
  id_token: string | null
  session_state: string | null
  oauth_token_secret: string | null
  oauth_token: string | null
}

/**
 * Model Session
 * 
 */
export type Session = {
  id: string
  sessionToken: string
  userId: string
  expires: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  role: Role
  name: string | null
  email: string | null
  emailVerified: Date | null
  image: string | null
}

/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = {
  identifier: string
  token: string
  expires: Date
}

/**
 * Model course
 * 
 */
export type course = {
  id: string
  created_at: Date | null
  instructor_id: string | null
  course_title: string
  updated_at: Date | null
  author: string | null
}

/**
 * Model enrollment
 * 
 */
export type enrollment = {
  id: string
  created_at: Date | null
  student_id: string | null
  course_id: string | null
  current_grade_level: string | null
}

/**
 * Model instructor
 * 
 */
export type instructor = {
  id: string
  created_at: Date | null
  user_id: string | null
}

/**
 * Model lesson
 * 
 */
export type lesson = {
  id: string
  created_at: Date | null
  updated_at: Date | null
  author: string | null
  lesson_module: string | null
}

/**
 * Model module
 * 
 */
export type module = {
  id: string
  created_at: Date | null
  updated_at: Date | null
  author: string | null
  module_subject_id: string | null
  module_name: string
}

/**
 * Model question_topic
 * 
 */
export type question_topic = {
  id: string
  topic_id: string
  question_id: string | null
}

/**
 * Model topic
 * 
 */
export type topic = {
  id: string
  created_at: Date | null
  updated_at: Date | null
  question_topic_name: string
}

/**
 * Model question
 * 
 */
export type question = {
  id: string
  created_at: Date | null
  difficulty: number | null
  image_url: string | null
  equation: string | null
  question_text: string | null
  answer_formula: string | null
  updated_at: Date | null
  author: string | null
}

/**
 * Model quiz_attempt
 * 
 */
export type quiz_attempt = {
  id: string
  created_at: Date | null
  student_id: string
  quiz_id: string
  total_points: number | null
  points_scored: number | null
  enroll_id: string | null
  answer_data: Prisma.JsonValue | null
  question_answered_count: number | null
  question_unanswered_count: number | null
}

/**
 * Model quiz_question
 * 
 */
export type quiz_question = {
  created_at: Date | null
  quiz_id: string
  question_id: string
  question_number: number | null
}

/**
 * Model quiz
 * 
 */
export type quiz = {
  id: string
  created_at: Date | null
  updated_at: Date | null
  author: string | null
}

/**
 * Model student_module
 * 
 */
export type student_module = {
  student_id: string
  module_id: string
  time_started: Date
}

/**
 * Model student
 * 
 */
export type student = {
  id: string
  created_at: Date | null
  grade_at_account_creation: number | null
  user_id: string | null
}

/**
 * Model subject
 * 
 */
export type subject = {
  id: string
  created_at: Date | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  INSTRUCTOR: 'INSTRUCTOR',
  STUDENT: 'STUDENT'
};

export type Role = (typeof Role)[keyof typeof Role]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<GlobalReject>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.courseDelegate<GlobalReject>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.enrollmentDelegate<GlobalReject>;

  /**
   * `prisma.instructor`: Exposes CRUD operations for the **instructor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instructors
    * const instructors = await prisma.instructor.findMany()
    * ```
    */
  get instructor(): Prisma.instructorDelegate<GlobalReject>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.lessonDelegate<GlobalReject>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.moduleDelegate<GlobalReject>;

  /**
   * `prisma.question_topic`: Exposes CRUD operations for the **question_topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Question_topics
    * const question_topics = await prisma.question_topic.findMany()
    * ```
    */
  get question_topic(): Prisma.question_topicDelegate<GlobalReject>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.topicDelegate<GlobalReject>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.questionDelegate<GlobalReject>;

  /**
   * `prisma.quiz_attempt`: Exposes CRUD operations for the **quiz_attempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quiz_attempts
    * const quiz_attempts = await prisma.quiz_attempt.findMany()
    * ```
    */
  get quiz_attempt(): Prisma.quiz_attemptDelegate<GlobalReject>;

  /**
   * `prisma.quiz_question`: Exposes CRUD operations for the **quiz_question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quiz_questions
    * const quiz_questions = await prisma.quiz_question.findMany()
    * ```
    */
  get quiz_question(): Prisma.quiz_questionDelegate<GlobalReject>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.quizDelegate<GlobalReject>;

  /**
   * `prisma.student_module`: Exposes CRUD operations for the **student_module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_modules
    * const student_modules = await prisma.student_module.findMany()
    * ```
    */
  get student_module(): Prisma.student_moduleDelegate<GlobalReject>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.studentDelegate<GlobalReject>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.subjectDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.11.0
   * Query Engine version: b371888aaf8f51357c7457d836b86d12da91658b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    course: 'course',
    enrollment: 'enrollment',
    instructor: 'instructor',
    lesson: 'lesson',
    module: 'module',
    question_topic: 'question_topic',
    topic: 'topic',
    question: 'question',
    quiz_attempt: 'quiz_attempt',
    quiz_question: 'quiz_question',
    quiz: 'quiz',
    student_module: 'student_module',
    student: 'student',
    subject: 'subject'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    accounts: number
    sessions: number
    instructor: number
    student: number
  }

  export type UserCountOutputTypeSelect = {
    accounts?: boolean
    sessions?: boolean
    instructor?: boolean
    student?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type CourseCountOutputType
   */


  export type CourseCountOutputType = {
    enrollment: number
  }

  export type CourseCountOutputTypeSelect = {
    enrollment?: boolean
  }

  export type CourseCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CourseCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CourseCountOutputType
    : S extends undefined
    ? never
    : S extends CourseCountOutputTypeArgs
    ?'include' extends U
    ? CourseCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CourseCountOutputType ? CourseCountOutputType[P] : never
  } 
    : CourseCountOutputType
  : CourseCountOutputType




  // Custom InputTypes

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     * 
    **/
    select?: CourseCountOutputTypeSelect | null
  }



  /**
   * Count Type EnrollmentCountOutputType
   */


  export type EnrollmentCountOutputType = {
    quiz_attempt: number
  }

  export type EnrollmentCountOutputTypeSelect = {
    quiz_attempt?: boolean
  }

  export type EnrollmentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EnrollmentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EnrollmentCountOutputType
    : S extends undefined
    ? never
    : S extends EnrollmentCountOutputTypeArgs
    ?'include' extends U
    ? EnrollmentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EnrollmentCountOutputType ? EnrollmentCountOutputType[P] : never
  } 
    : EnrollmentCountOutputType
  : EnrollmentCountOutputType




  // Custom InputTypes

  /**
   * EnrollmentCountOutputType without action
   */
  export type EnrollmentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EnrollmentCountOutputType
     * 
    **/
    select?: EnrollmentCountOutputTypeSelect | null
  }



  /**
   * Count Type ModuleCountOutputType
   */


  export type ModuleCountOutputType = {
    lesson: number
    student_module: number
  }

  export type ModuleCountOutputTypeSelect = {
    lesson?: boolean
    student_module?: boolean
  }

  export type ModuleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ModuleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ModuleCountOutputType
    : S extends undefined
    ? never
    : S extends ModuleCountOutputTypeArgs
    ?'include' extends U
    ? ModuleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ModuleCountOutputType ? ModuleCountOutputType[P] : never
  } 
    : ModuleCountOutputType
  : ModuleCountOutputType




  // Custom InputTypes

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     * 
    **/
    select?: ModuleCountOutputTypeSelect | null
  }



  /**
   * Count Type TopicCountOutputType
   */


  export type TopicCountOutputType = {
    question_topic: number
  }

  export type TopicCountOutputTypeSelect = {
    question_topic?: boolean
  }

  export type TopicCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TopicCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TopicCountOutputType
    : S extends undefined
    ? never
    : S extends TopicCountOutputTypeArgs
    ?'include' extends U
    ? TopicCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TopicCountOutputType ? TopicCountOutputType[P] : never
  } 
    : TopicCountOutputType
  : TopicCountOutputType




  // Custom InputTypes

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     * 
    **/
    select?: TopicCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionCountOutputType
   */


  export type QuestionCountOutputType = {
    question_topic: number
  }

  export type QuestionCountOutputTypeSelect = {
    question_topic?: boolean
  }

  export type QuestionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionCountOutputTypeArgs
    ?'include' extends U
    ? QuestionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuestionCountOutputType ? QuestionCountOutputType[P] : never
  } 
    : QuestionCountOutputType
  : QuestionCountOutputType




  // Custom InputTypes

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     * 
    **/
    select?: QuestionCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizCountOutputType
   */


  export type QuizCountOutputType = {
    attempts: number
    questions: number
  }

  export type QuizCountOutputTypeSelect = {
    attempts?: boolean
    questions?: boolean
  }

  export type QuizCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuizCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuizCountOutputType
    : S extends undefined
    ? never
    : S extends QuizCountOutputTypeArgs
    ?'include' extends U
    ? QuizCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuizCountOutputType ? QuizCountOutputType[P] : never
  } 
    : QuizCountOutputType
  : QuizCountOutputType




  // Custom InputTypes

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     * 
    **/
    select?: QuizCountOutputTypeSelect | null
  }



  /**
   * Count Type StudentCountOutputType
   */


  export type StudentCountOutputType = {
    enrollment: number
    quiz_attempt: number
    student_module: number
  }

  export type StudentCountOutputTypeSelect = {
    enrollment?: boolean
    quiz_attempt?: boolean
    student_module?: boolean
  }

  export type StudentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StudentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StudentCountOutputType
    : S extends undefined
    ? never
    : S extends StudentCountOutputTypeArgs
    ?'include' extends U
    ? StudentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof StudentCountOutputType ? StudentCountOutputType[P] : never
  } 
    : StudentCountOutputType
  : StudentCountOutputType




  // Custom InputTypes

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     * 
    **/
    select?: StudentCountOutputTypeSelect | null
  }



  /**
   * Count Type SubjectCountOutputType
   */


  export type SubjectCountOutputType = {
    module: number
  }

  export type SubjectCountOutputTypeSelect = {
    module?: boolean
  }

  export type SubjectCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SubjectCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SubjectCountOutputType
    : S extends undefined
    ? never
    : S extends SubjectCountOutputTypeArgs
    ?'include' extends U
    ? SubjectCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SubjectCountOutputType ? SubjectCountOutputType[P] : never
  } 
    : SubjectCountOutputType
  : SubjectCountOutputType




  // Custom InputTypes

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     * 
    **/
    select?: SubjectCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    oauth_token_secret: number
    oauth_token: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    oauth_token_secret?: true
    oauth_token?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which Account to aggregate.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: Array<AccountScalarFieldEnum>
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    oauth_token_secret: string | null
    oauth_token: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    oauth_token_secret?: boolean
    oauth_token?: boolean
    user?: boolean | UserArgs
  }

  export type AccountInclude = {
    user?: boolean | UserArgs
  }

  export type AccountGetPayload<
    S extends boolean | null | undefined | AccountArgs,
    U = keyof S
      > = S extends true
        ? Account
    : S extends undefined
    ? never
    : S extends AccountArgs | AccountFindManyArgs
    ?'include' extends U
    ? Account  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Account ? Account[P] : never
  } 
    : Account
  : Account


  type AccountCountArgs = Merge<
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }
  >

  export interface AccountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null >, Prisma__AccountClient<AccountGetPayload<T> | null >>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>> : CheckSelect<T, Prisma__AccountClient<Account | null >, Prisma__AccountClient<AccountGetPayload<T> | null >>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs>
    ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Throw an Error if a Account can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Throw an Error if a Account can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Account to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to create a Account.
     * 
    **/
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     * 
    **/
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The data needed to update a Account.
     * 
    **/
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     * 
    **/
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * The filter to search for the Account to update in case it exists.
     * 
    **/
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     * 
    **/
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
    /**
     * Filter which Account to delete.
     * 
    **/
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     * 
    **/
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountArgs = {
    /**
     * Select specific fields to fetch from the Account
     * 
    **/
    select?: AccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: Array<SessionScalarFieldEnum>
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserArgs
  }

  export type SessionInclude = {
    user?: boolean | UserArgs
  }

  export type SessionGetPayload<
    S extends boolean | null | undefined | SessionArgs,
    U = keyof S
      > = S extends true
        ? Session
    : S extends undefined
    ? never
    : S extends SessionArgs | SessionFindManyArgs
    ?'include' extends U
    ? Session  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Session ? Session[P] : never
  } 
    : Session
  : Session


  type SessionCountArgs = Merge<
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }
  >

  export interface SessionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null >, Prisma__SessionClient<SessionGetPayload<T> | null >>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null >, Prisma__SessionClient<SessionGetPayload<T> | null >>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Throw an Error if a Session can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Throw an Error if a Session can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to create a Session.
     * 
    **/
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    /**
     * The data used to create many Sessions.
     * 
    **/
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to update a Session.
     * 
    **/
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    /**
     * The data used to update Sessions.
     * 
    **/
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The filter to search for the Session to update in case it exists.
     * 
    **/
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     * 
    **/
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter which Session to delete.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    /**
     * Filter which Sessions to delete
     * 
    **/
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    role: Role | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    role: Role | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    role: number
    name: number
    email: number
    emailVerified: number
    image: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    role?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    role: Role
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    accounts?: boolean | AccountFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    instructor?: boolean | instructorFindManyArgs
    student?: boolean | studentFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    accounts?: boolean | AccountFindManyArgs
    sessions?: boolean | SessionFindManyArgs
    instructor?: boolean | instructorFindManyArgs
    student?: boolean | studentFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'accounts' ? Array < AccountGetPayload<S['include'][P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<S['include'][P]>>  :
        P extends 'instructor' ? Array < instructorGetPayload<S['include'][P]>>  :
        P extends 'student' ? Array < studentGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'accounts' ? Array < AccountGetPayload<S['select'][P]>>  :
        P extends 'sessions' ? Array < SessionGetPayload<S['select'][P]>>  :
        P extends 'instructor' ? Array < instructorGetPayload<S['select'][P]>>  :
        P extends 'student' ? Array < studentGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    accounts<T extends AccountFindManyArgs = {}>(args?: Subset<T, AccountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Account>>, PrismaPromise<Array<AccountGetPayload<T>>>>;

    sessions<T extends SessionFindManyArgs = {}>(args?: Subset<T, SessionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>;

    instructor<T extends instructorFindManyArgs = {}>(args?: Subset<T, instructorFindManyArgs>): CheckSelect<T, PrismaPromise<Array<instructor>>, PrismaPromise<Array<instructorGetPayload<T>>>>;

    student<T extends studentFindManyArgs = {}>(args?: Subset<T, studentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<student>>, PrismaPromise<Array<studentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model VerificationToken
   */


  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs = {
    /**
     * Filter which VerificationToken to aggregate.
     * 
    **/
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs = {
    where?: VerificationTokenWhereInput
    orderBy?: Enumerable<VerificationTokenOrderByWithAggregationInput>
    by: Array<VerificationTokenScalarFieldEnum>
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }


  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenArgs,
    U = keyof S
      > = S extends true
        ? VerificationToken
    : S extends undefined
    ? never
    : S extends VerificationTokenArgs | VerificationTokenFindManyArgs
    ?'include' extends U
    ? VerificationToken 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof VerificationToken ? VerificationToken[P] : never
  } 
    : VerificationToken
  : VerificationToken


  type VerificationTokenCountArgs = Merge<
    Omit<VerificationTokenFindManyArgs, 'select' | 'include'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }
  >

  export interface VerificationTokenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VerificationToken'> extends True ? CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>> : CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken | null >, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T> | null >>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VerificationToken'> extends True ? CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>> : CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken | null >, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T> | null >>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
    **/
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VerificationToken>>, PrismaPromise<Array<VerificationTokenGetPayload<T>>>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
    **/
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Create many VerificationTokens.
     *     @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     *     @example
     *     // Create many VerificationTokens
     *     const verificationToken = await prisma.verificationToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
    **/
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs>
    ): CheckSelect<T, Prisma__VerificationTokenClient<VerificationToken>, Prisma__VerificationTokenClient<VerificationTokenGetPayload<T>>>

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VerificationTokenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Throw an Error if a VerificationToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VerificationToken to fetch.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Throw an Error if a VerificationToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VerificationToken to fetch.
     * 
    **/
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     * 
    **/
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     * 
    **/
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }


  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter, which VerificationTokens to fetch.
     * 
    **/
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     * 
    **/
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }


  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * The data needed to create a VerificationToken.
     * 
    **/
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }


  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs = {
    /**
     * The data used to create many VerificationTokens.
     * 
    **/
    data: Enumerable<VerificationTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * The data needed to update a VerificationToken.
     * 
    **/
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs = {
    /**
     * The data used to update VerificationTokens.
     * 
    **/
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     * 
    **/
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     * 
    **/
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }


  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
    /**
     * Filter which VerificationToken to delete.
     * 
    **/
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs = {
    /**
     * Filter which VerificationTokens to delete
     * 
    **/
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken without action
   */
  export type VerificationTokenArgs = {
    /**
     * Select specific fields to fetch from the VerificationToken
     * 
    **/
    select?: VerificationTokenSelect | null
  }



  /**
   * Model course
   */


  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    instructor_id: string | null
    course_title: string | null
    updated_at: Date | null
    author: string | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    instructor_id: string | null
    course_title: string | null
    updated_at: Date | null
    author: string | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    created_at: number
    instructor_id: number
    course_title: number
    updated_at: number
    author: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    id?: true
    created_at?: true
    instructor_id?: true
    course_title?: true
    updated_at?: true
    author?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    created_at?: true
    instructor_id?: true
    course_title?: true
    updated_at?: true
    author?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    created_at?: true
    instructor_id?: true
    course_title?: true
    updated_at?: true
    author?: true
    _all?: true
  }

  export type CourseAggregateArgs = {
    /**
     * Filter which course to aggregate.
     * 
    **/
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     * 
    **/
    orderBy?: Enumerable<courseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs = {
    where?: courseWhereInput
    orderBy?: Enumerable<courseOrderByWithAggregationInput>
    by: Array<CourseScalarFieldEnum>
    having?: courseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }


  export type CourseGroupByOutputType = {
    id: string
    created_at: Date | null
    instructor_id: string | null
    course_title: string
    updated_at: Date | null
    author: string | null
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type courseSelect = {
    id?: boolean
    created_at?: boolean
    instructor_id?: boolean
    course_title?: boolean
    updated_at?: boolean
    author?: boolean
    enrollment?: boolean | enrollmentFindManyArgs
    _count?: boolean | CourseCountOutputTypeArgs
  }

  export type courseInclude = {
    enrollment?: boolean | enrollmentFindManyArgs
    _count?: boolean | CourseCountOutputTypeArgs
  }

  export type courseGetPayload<
    S extends boolean | null | undefined | courseArgs,
    U = keyof S
      > = S extends true
        ? course
    : S extends undefined
    ? never
    : S extends courseArgs | courseFindManyArgs
    ?'include' extends U
    ? course  & {
    [P in TrueKeys<S['include']>]:
        P extends 'enrollment' ? Array < enrollmentGetPayload<S['include'][P]>>  :
        P extends '_count' ? CourseCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'enrollment' ? Array < enrollmentGetPayload<S['select'][P]>>  :
        P extends '_count' ? CourseCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof course ? course[P] : never
  } 
    : course
  : course


  type courseCountArgs = Merge<
    Omit<courseFindManyArgs, 'select' | 'include'> & {
      select?: CourseCountAggregateInputType | true
    }
  >

  export interface courseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Course that matches the filter.
     * @param {courseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends courseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, courseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'course'> extends True ? CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>> : CheckSelect<T, Prisma__courseClient<course | null >, Prisma__courseClient<courseGetPayload<T> | null >>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends courseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, courseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'course'> extends True ? CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>> : CheckSelect<T, Prisma__courseClient<course | null >, Prisma__courseClient<courseGetPayload<T> | null >>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends courseFindManyArgs>(
      args?: SelectSubset<T, courseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<course>>, PrismaPromise<Array<courseGetPayload<T>>>>

    /**
     * Create a Course.
     * @param {courseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
    **/
    create<T extends courseCreateArgs>(
      args: SelectSubset<T, courseCreateArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Create many Courses.
     *     @param {courseCreateManyArgs} args - Arguments to create many Courses.
     *     @example
     *     // Create many Courses
     *     const course = await prisma.course.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends courseCreateManyArgs>(
      args?: SelectSubset<T, courseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {courseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
    **/
    delete<T extends courseDeleteArgs>(
      args: SelectSubset<T, courseDeleteArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Update one Course.
     * @param {courseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends courseUpdateArgs>(
      args: SelectSubset<T, courseUpdateArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Delete zero or more Courses.
     * @param {courseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends courseDeleteManyArgs>(
      args?: SelectSubset<T, courseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends courseUpdateManyArgs>(
      args: SelectSubset<T, courseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {courseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
    **/
    upsert<T extends courseUpsertArgs>(
      args: SelectSubset<T, courseUpsertArgs>
    ): CheckSelect<T, Prisma__courseClient<course>, Prisma__courseClient<courseGetPayload<T>>>

    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends courseCountArgs>(
      args?: Subset<T, courseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__courseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    enrollment<T extends enrollmentFindManyArgs = {}>(args?: Subset<T, enrollmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<enrollment>>, PrismaPromise<Array<enrollmentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * course findUnique
   */
  export type courseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: courseInclude | null
    /**
     * Throw an Error if a course can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which course to fetch.
     * 
    **/
    where: courseWhereUniqueInput
  }


  /**
   * course findFirst
   */
  export type courseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: courseInclude | null
    /**
     * Throw an Error if a course can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which course to fetch.
     * 
    **/
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     * 
    **/
    orderBy?: Enumerable<courseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     * 
    **/
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     * 
    **/
    distinct?: Enumerable<CourseScalarFieldEnum>
  }


  /**
   * course findMany
   */
  export type courseFindManyArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: courseInclude | null
    /**
     * Filter, which courses to fetch.
     * 
    **/
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     * 
    **/
    orderBy?: Enumerable<courseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing courses.
     * 
    **/
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CourseScalarFieldEnum>
  }


  /**
   * course create
   */
  export type courseCreateArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: courseInclude | null
    /**
     * The data needed to create a course.
     * 
    **/
    data: XOR<courseCreateInput, courseUncheckedCreateInput>
  }


  /**
   * course createMany
   */
  export type courseCreateManyArgs = {
    /**
     * The data used to create many courses.
     * 
    **/
    data: Enumerable<courseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * course update
   */
  export type courseUpdateArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: courseInclude | null
    /**
     * The data needed to update a course.
     * 
    **/
    data: XOR<courseUpdateInput, courseUncheckedUpdateInput>
    /**
     * Choose, which course to update.
     * 
    **/
    where: courseWhereUniqueInput
  }


  /**
   * course updateMany
   */
  export type courseUpdateManyArgs = {
    /**
     * The data used to update courses.
     * 
    **/
    data: XOR<courseUpdateManyMutationInput, courseUncheckedUpdateManyInput>
    /**
     * Filter which courses to update
     * 
    **/
    where?: courseWhereInput
  }


  /**
   * course upsert
   */
  export type courseUpsertArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: courseInclude | null
    /**
     * The filter to search for the course to update in case it exists.
     * 
    **/
    where: courseWhereUniqueInput
    /**
     * In case the course found by the `where` argument doesn't exist, create a new course with this data.
     * 
    **/
    create: XOR<courseCreateInput, courseUncheckedCreateInput>
    /**
     * In case the course was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<courseUpdateInput, courseUncheckedUpdateInput>
  }


  /**
   * course delete
   */
  export type courseDeleteArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: courseInclude | null
    /**
     * Filter which course to delete.
     * 
    **/
    where: courseWhereUniqueInput
  }


  /**
   * course deleteMany
   */
  export type courseDeleteManyArgs = {
    /**
     * Filter which courses to delete
     * 
    **/
    where?: courseWhereInput
  }


  /**
   * course without action
   */
  export type courseArgs = {
    /**
     * Select specific fields to fetch from the course
     * 
    **/
    select?: courseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: courseInclude | null
  }



  /**
   * Model enrollment
   */


  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    student_id: string | null
    course_id: string | null
    current_grade_level: string | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    student_id: string | null
    course_id: string | null
    current_grade_level: string | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    created_at: number
    student_id: number
    course_id: number
    current_grade_level: number
    _all: number
  }


  export type EnrollmentMinAggregateInputType = {
    id?: true
    created_at?: true
    student_id?: true
    course_id?: true
    current_grade_level?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    created_at?: true
    student_id?: true
    course_id?: true
    current_grade_level?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    created_at?: true
    student_id?: true
    course_id?: true
    current_grade_level?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs = {
    /**
     * Filter which enrollment to aggregate.
     * 
    **/
    where?: enrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     * 
    **/
    orderBy?: Enumerable<enrollmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: enrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs = {
    where?: enrollmentWhereInput
    orderBy?: Enumerable<enrollmentOrderByWithAggregationInput>
    by: Array<EnrollmentScalarFieldEnum>
    having?: enrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }


  export type EnrollmentGroupByOutputType = {
    id: string
    created_at: Date | null
    student_id: string | null
    course_id: string | null
    current_grade_level: string | null
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type enrollmentSelect = {
    id?: boolean
    created_at?: boolean
    student_id?: boolean
    course_id?: boolean
    current_grade_level?: boolean
    course?: boolean | courseArgs
    student?: boolean | studentArgs
    quiz_attempt?: boolean | quiz_attemptFindManyArgs
    _count?: boolean | EnrollmentCountOutputTypeArgs
  }

  export type enrollmentInclude = {
    course?: boolean | courseArgs
    student?: boolean | studentArgs
    quiz_attempt?: boolean | quiz_attemptFindManyArgs
    _count?: boolean | EnrollmentCountOutputTypeArgs
  }

  export type enrollmentGetPayload<
    S extends boolean | null | undefined | enrollmentArgs,
    U = keyof S
      > = S extends true
        ? enrollment
    : S extends undefined
    ? never
    : S extends enrollmentArgs | enrollmentFindManyArgs
    ?'include' extends U
    ? enrollment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'course' ? courseGetPayload<S['include'][P]> | null :
        P extends 'student' ? studentGetPayload<S['include'][P]> | null :
        P extends 'quiz_attempt' ? Array < quiz_attemptGetPayload<S['include'][P]>>  :
        P extends '_count' ? EnrollmentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'course' ? courseGetPayload<S['select'][P]> | null :
        P extends 'student' ? studentGetPayload<S['select'][P]> | null :
        P extends 'quiz_attempt' ? Array < quiz_attemptGetPayload<S['select'][P]>>  :
        P extends '_count' ? EnrollmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof enrollment ? enrollment[P] : never
  } 
    : enrollment
  : enrollment


  type enrollmentCountArgs = Merge<
    Omit<enrollmentFindManyArgs, 'select' | 'include'> & {
      select?: EnrollmentCountAggregateInputType | true
    }
  >

  export interface enrollmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {enrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends enrollmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, enrollmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'enrollment'> extends True ? CheckSelect<T, Prisma__enrollmentClient<enrollment>, Prisma__enrollmentClient<enrollmentGetPayload<T>>> : CheckSelect<T, Prisma__enrollmentClient<enrollment | null >, Prisma__enrollmentClient<enrollmentGetPayload<T> | null >>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends enrollmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, enrollmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'enrollment'> extends True ? CheckSelect<T, Prisma__enrollmentClient<enrollment>, Prisma__enrollmentClient<enrollmentGetPayload<T>>> : CheckSelect<T, Prisma__enrollmentClient<enrollment | null >, Prisma__enrollmentClient<enrollmentGetPayload<T> | null >>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends enrollmentFindManyArgs>(
      args?: SelectSubset<T, enrollmentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<enrollment>>, PrismaPromise<Array<enrollmentGetPayload<T>>>>

    /**
     * Create a Enrollment.
     * @param {enrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
    **/
    create<T extends enrollmentCreateArgs>(
      args: SelectSubset<T, enrollmentCreateArgs>
    ): CheckSelect<T, Prisma__enrollmentClient<enrollment>, Prisma__enrollmentClient<enrollmentGetPayload<T>>>

    /**
     * Create many Enrollments.
     *     @param {enrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     *     @example
     *     // Create many Enrollments
     *     const enrollment = await prisma.enrollment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends enrollmentCreateManyArgs>(
      args?: SelectSubset<T, enrollmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Enrollment.
     * @param {enrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
    **/
    delete<T extends enrollmentDeleteArgs>(
      args: SelectSubset<T, enrollmentDeleteArgs>
    ): CheckSelect<T, Prisma__enrollmentClient<enrollment>, Prisma__enrollmentClient<enrollmentGetPayload<T>>>

    /**
     * Update one Enrollment.
     * @param {enrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends enrollmentUpdateArgs>(
      args: SelectSubset<T, enrollmentUpdateArgs>
    ): CheckSelect<T, Prisma__enrollmentClient<enrollment>, Prisma__enrollmentClient<enrollmentGetPayload<T>>>

    /**
     * Delete zero or more Enrollments.
     * @param {enrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends enrollmentDeleteManyArgs>(
      args?: SelectSubset<T, enrollmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends enrollmentUpdateManyArgs>(
      args: SelectSubset<T, enrollmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Enrollment.
     * @param {enrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
    **/
    upsert<T extends enrollmentUpsertArgs>(
      args: SelectSubset<T, enrollmentUpsertArgs>
    ): CheckSelect<T, Prisma__enrollmentClient<enrollment>, Prisma__enrollmentClient<enrollmentGetPayload<T>>>

    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends enrollmentCountArgs>(
      args?: Subset<T, enrollmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__enrollmentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    course<T extends courseArgs = {}>(args?: Subset<T, courseArgs>): CheckSelect<T, Prisma__courseClient<course | null >, Prisma__courseClient<courseGetPayload<T> | null >>;

    student<T extends studentArgs = {}>(args?: Subset<T, studentArgs>): CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>;

    quiz_attempt<T extends quiz_attemptFindManyArgs = {}>(args?: Subset<T, quiz_attemptFindManyArgs>): CheckSelect<T, PrismaPromise<Array<quiz_attempt>>, PrismaPromise<Array<quiz_attemptGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * enrollment findUnique
   */
  export type enrollmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the enrollment
     * 
    **/
    select?: enrollmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: enrollmentInclude | null
    /**
     * Throw an Error if a enrollment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which enrollment to fetch.
     * 
    **/
    where: enrollmentWhereUniqueInput
  }


  /**
   * enrollment findFirst
   */
  export type enrollmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the enrollment
     * 
    **/
    select?: enrollmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: enrollmentInclude | null
    /**
     * Throw an Error if a enrollment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which enrollment to fetch.
     * 
    **/
    where?: enrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     * 
    **/
    orderBy?: Enumerable<enrollmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrollments.
     * 
    **/
    cursor?: enrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrollments.
     * 
    **/
    distinct?: Enumerable<EnrollmentScalarFieldEnum>
  }


  /**
   * enrollment findMany
   */
  export type enrollmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the enrollment
     * 
    **/
    select?: enrollmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: enrollmentInclude | null
    /**
     * Filter, which enrollments to fetch.
     * 
    **/
    where?: enrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     * 
    **/
    orderBy?: Enumerable<enrollmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing enrollments.
     * 
    **/
    cursor?: enrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EnrollmentScalarFieldEnum>
  }


  /**
   * enrollment create
   */
  export type enrollmentCreateArgs = {
    /**
     * Select specific fields to fetch from the enrollment
     * 
    **/
    select?: enrollmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: enrollmentInclude | null
    /**
     * The data needed to create a enrollment.
     * 
    **/
    data: XOR<enrollmentCreateInput, enrollmentUncheckedCreateInput>
  }


  /**
   * enrollment createMany
   */
  export type enrollmentCreateManyArgs = {
    /**
     * The data used to create many enrollments.
     * 
    **/
    data: Enumerable<enrollmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * enrollment update
   */
  export type enrollmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the enrollment
     * 
    **/
    select?: enrollmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: enrollmentInclude | null
    /**
     * The data needed to update a enrollment.
     * 
    **/
    data: XOR<enrollmentUpdateInput, enrollmentUncheckedUpdateInput>
    /**
     * Choose, which enrollment to update.
     * 
    **/
    where: enrollmentWhereUniqueInput
  }


  /**
   * enrollment updateMany
   */
  export type enrollmentUpdateManyArgs = {
    /**
     * The data used to update enrollments.
     * 
    **/
    data: XOR<enrollmentUpdateManyMutationInput, enrollmentUncheckedUpdateManyInput>
    /**
     * Filter which enrollments to update
     * 
    **/
    where?: enrollmentWhereInput
  }


  /**
   * enrollment upsert
   */
  export type enrollmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the enrollment
     * 
    **/
    select?: enrollmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: enrollmentInclude | null
    /**
     * The filter to search for the enrollment to update in case it exists.
     * 
    **/
    where: enrollmentWhereUniqueInput
    /**
     * In case the enrollment found by the `where` argument doesn't exist, create a new enrollment with this data.
     * 
    **/
    create: XOR<enrollmentCreateInput, enrollmentUncheckedCreateInput>
    /**
     * In case the enrollment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<enrollmentUpdateInput, enrollmentUncheckedUpdateInput>
  }


  /**
   * enrollment delete
   */
  export type enrollmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the enrollment
     * 
    **/
    select?: enrollmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: enrollmentInclude | null
    /**
     * Filter which enrollment to delete.
     * 
    **/
    where: enrollmentWhereUniqueInput
  }


  /**
   * enrollment deleteMany
   */
  export type enrollmentDeleteManyArgs = {
    /**
     * Filter which enrollments to delete
     * 
    **/
    where?: enrollmentWhereInput
  }


  /**
   * enrollment without action
   */
  export type enrollmentArgs = {
    /**
     * Select specific fields to fetch from the enrollment
     * 
    **/
    select?: enrollmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: enrollmentInclude | null
  }



  /**
   * Model instructor
   */


  export type AggregateInstructor = {
    _count: InstructorCountAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  export type InstructorMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    user_id: string | null
  }

  export type InstructorMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    user_id: string | null
  }

  export type InstructorCountAggregateOutputType = {
    id: number
    created_at: number
    user_id: number
    _all: number
  }


  export type InstructorMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
  }

  export type InstructorMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
  }

  export type InstructorCountAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    _all?: true
  }

  export type InstructorAggregateArgs = {
    /**
     * Filter which instructor to aggregate.
     * 
    **/
    where?: instructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instructors to fetch.
     * 
    **/
    orderBy?: Enumerable<instructorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: instructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instructors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instructors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned instructors
    **/
    _count?: true | InstructorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructorMaxAggregateInputType
  }

  export type GetInstructorAggregateType<T extends InstructorAggregateArgs> = {
        [P in keyof T & keyof AggregateInstructor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstructor[P]>
      : GetScalarType<T[P], AggregateInstructor[P]>
  }




  export type InstructorGroupByArgs = {
    where?: instructorWhereInput
    orderBy?: Enumerable<instructorOrderByWithAggregationInput>
    by: Array<InstructorScalarFieldEnum>
    having?: instructorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructorCountAggregateInputType | true
    _min?: InstructorMinAggregateInputType
    _max?: InstructorMaxAggregateInputType
  }


  export type InstructorGroupByOutputType = {
    id: string
    created_at: Date | null
    user_id: string | null
    _count: InstructorCountAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  type GetInstructorGroupByPayload<T extends InstructorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InstructorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructorGroupByOutputType[P]>
            : GetScalarType<T[P], InstructorGroupByOutputType[P]>
        }
      >
    >


  export type instructorSelect = {
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    User?: boolean | UserArgs
  }

  export type instructorInclude = {
    User?: boolean | UserArgs
  }

  export type instructorGetPayload<
    S extends boolean | null | undefined | instructorArgs,
    U = keyof S
      > = S extends true
        ? instructor
    : S extends undefined
    ? never
    : S extends instructorArgs | instructorFindManyArgs
    ?'include' extends U
    ? instructor  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :  P extends keyof instructor ? instructor[P] : never
  } 
    : instructor
  : instructor


  type instructorCountArgs = Merge<
    Omit<instructorFindManyArgs, 'select' | 'include'> & {
      select?: InstructorCountAggregateInputType | true
    }
  >

  export interface instructorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Instructor that matches the filter.
     * @param {instructorFindUniqueArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends instructorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, instructorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'instructor'> extends True ? CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>> : CheckSelect<T, Prisma__instructorClient<instructor | null >, Prisma__instructorClient<instructorGetPayload<T> | null >>

    /**
     * Find the first Instructor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instructorFindFirstArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends instructorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, instructorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'instructor'> extends True ? CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>> : CheckSelect<T, Prisma__instructorClient<instructor | null >, Prisma__instructorClient<instructorGetPayload<T> | null >>

    /**
     * Find zero or more Instructors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instructorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instructors
     * const instructors = await prisma.instructor.findMany()
     * 
     * // Get first 10 Instructors
     * const instructors = await prisma.instructor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instructorWithIdOnly = await prisma.instructor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends instructorFindManyArgs>(
      args?: SelectSubset<T, instructorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<instructor>>, PrismaPromise<Array<instructorGetPayload<T>>>>

    /**
     * Create a Instructor.
     * @param {instructorCreateArgs} args - Arguments to create a Instructor.
     * @example
     * // Create one Instructor
     * const Instructor = await prisma.instructor.create({
     *   data: {
     *     // ... data to create a Instructor
     *   }
     * })
     * 
    **/
    create<T extends instructorCreateArgs>(
      args: SelectSubset<T, instructorCreateArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Create many Instructors.
     *     @param {instructorCreateManyArgs} args - Arguments to create many Instructors.
     *     @example
     *     // Create many Instructors
     *     const instructor = await prisma.instructor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends instructorCreateManyArgs>(
      args?: SelectSubset<T, instructorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Instructor.
     * @param {instructorDeleteArgs} args - Arguments to delete one Instructor.
     * @example
     * // Delete one Instructor
     * const Instructor = await prisma.instructor.delete({
     *   where: {
     *     // ... filter to delete one Instructor
     *   }
     * })
     * 
    **/
    delete<T extends instructorDeleteArgs>(
      args: SelectSubset<T, instructorDeleteArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Update one Instructor.
     * @param {instructorUpdateArgs} args - Arguments to update one Instructor.
     * @example
     * // Update one Instructor
     * const instructor = await prisma.instructor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends instructorUpdateArgs>(
      args: SelectSubset<T, instructorUpdateArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Delete zero or more Instructors.
     * @param {instructorDeleteManyArgs} args - Arguments to filter Instructors to delete.
     * @example
     * // Delete a few Instructors
     * const { count } = await prisma.instructor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends instructorDeleteManyArgs>(
      args?: SelectSubset<T, instructorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instructorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instructors
     * const instructor = await prisma.instructor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends instructorUpdateManyArgs>(
      args: SelectSubset<T, instructorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Instructor.
     * @param {instructorUpsertArgs} args - Arguments to update or create a Instructor.
     * @example
     * // Update or create a Instructor
     * const instructor = await prisma.instructor.upsert({
     *   create: {
     *     // ... data to create a Instructor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instructor we want to update
     *   }
     * })
    **/
    upsert<T extends instructorUpsertArgs>(
      args: SelectSubset<T, instructorUpsertArgs>
    ): CheckSelect<T, Prisma__instructorClient<instructor>, Prisma__instructorClient<instructorGetPayload<T>>>

    /**
     * Count the number of Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {instructorCountArgs} args - Arguments to filter Instructors to count.
     * @example
     * // Count the number of Instructors
     * const count = await prisma.instructor.count({
     *   where: {
     *     // ... the filter for the Instructors we want to count
     *   }
     * })
    **/
    count<T extends instructorCountArgs>(
      args?: Subset<T, instructorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructorAggregateArgs>(args: Subset<T, InstructorAggregateArgs>): PrismaPromise<GetInstructorAggregateType<T>>

    /**
     * Group by Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructorGroupByArgs['orderBy'] }
        : { orderBy?: InstructorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructorGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for instructor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__instructorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * instructor findUnique
   */
  export type instructorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * Throw an Error if a instructor can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which instructor to fetch.
     * 
    **/
    where: instructorWhereUniqueInput
  }


  /**
   * instructor findFirst
   */
  export type instructorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * Throw an Error if a instructor can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which instructor to fetch.
     * 
    **/
    where?: instructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instructors to fetch.
     * 
    **/
    orderBy?: Enumerable<instructorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for instructors.
     * 
    **/
    cursor?: instructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instructors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instructors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of instructors.
     * 
    **/
    distinct?: Enumerable<InstructorScalarFieldEnum>
  }


  /**
   * instructor findMany
   */
  export type instructorFindManyArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * Filter, which instructors to fetch.
     * 
    **/
    where?: instructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of instructors to fetch.
     * 
    **/
    orderBy?: Enumerable<instructorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing instructors.
     * 
    **/
    cursor?: instructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` instructors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` instructors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InstructorScalarFieldEnum>
  }


  /**
   * instructor create
   */
  export type instructorCreateArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * The data needed to create a instructor.
     * 
    **/
    data: XOR<instructorCreateInput, instructorUncheckedCreateInput>
  }


  /**
   * instructor createMany
   */
  export type instructorCreateManyArgs = {
    /**
     * The data used to create many instructors.
     * 
    **/
    data: Enumerable<instructorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * instructor update
   */
  export type instructorUpdateArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * The data needed to update a instructor.
     * 
    **/
    data: XOR<instructorUpdateInput, instructorUncheckedUpdateInput>
    /**
     * Choose, which instructor to update.
     * 
    **/
    where: instructorWhereUniqueInput
  }


  /**
   * instructor updateMany
   */
  export type instructorUpdateManyArgs = {
    /**
     * The data used to update instructors.
     * 
    **/
    data: XOR<instructorUpdateManyMutationInput, instructorUncheckedUpdateManyInput>
    /**
     * Filter which instructors to update
     * 
    **/
    where?: instructorWhereInput
  }


  /**
   * instructor upsert
   */
  export type instructorUpsertArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * The filter to search for the instructor to update in case it exists.
     * 
    **/
    where: instructorWhereUniqueInput
    /**
     * In case the instructor found by the `where` argument doesn't exist, create a new instructor with this data.
     * 
    **/
    create: XOR<instructorCreateInput, instructorUncheckedCreateInput>
    /**
     * In case the instructor was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<instructorUpdateInput, instructorUncheckedUpdateInput>
  }


  /**
   * instructor delete
   */
  export type instructorDeleteArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
    /**
     * Filter which instructor to delete.
     * 
    **/
    where: instructorWhereUniqueInput
  }


  /**
   * instructor deleteMany
   */
  export type instructorDeleteManyArgs = {
    /**
     * Filter which instructors to delete
     * 
    **/
    where?: instructorWhereInput
  }


  /**
   * instructor without action
   */
  export type instructorArgs = {
    /**
     * Select specific fields to fetch from the instructor
     * 
    **/
    select?: instructorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: instructorInclude | null
  }



  /**
   * Model lesson
   */


  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    author: string | null
    lesson_module: string | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    author: string | null
    lesson_module: string | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    author: number
    lesson_module: number
    _all: number
  }


  export type LessonMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    author?: true
    lesson_module?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    author?: true
    lesson_module?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    author?: true
    lesson_module?: true
    _all?: true
  }

  export type LessonAggregateArgs = {
    /**
     * Filter which lesson to aggregate.
     * 
    **/
    where?: lessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     * 
    **/
    orderBy?: Enumerable<lessonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: lessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs = {
    where?: lessonWhereInput
    orderBy?: Enumerable<lessonOrderByWithAggregationInput>
    by: Array<LessonScalarFieldEnum>
    having?: lessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }


  export type LessonGroupByOutputType = {
    id: string
    created_at: Date | null
    updated_at: Date | null
    author: string | null
    lesson_module: string | null
    _count: LessonCountAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type lessonSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    author?: boolean
    lesson_module?: boolean
    module?: boolean | moduleArgs
  }

  export type lessonInclude = {
    module?: boolean | moduleArgs
  }

  export type lessonGetPayload<
    S extends boolean | null | undefined | lessonArgs,
    U = keyof S
      > = S extends true
        ? lesson
    : S extends undefined
    ? never
    : S extends lessonArgs | lessonFindManyArgs
    ?'include' extends U
    ? lesson  & {
    [P in TrueKeys<S['include']>]:
        P extends 'module' ? moduleGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'module' ? moduleGetPayload<S['select'][P]> | null :  P extends keyof lesson ? lesson[P] : never
  } 
    : lesson
  : lesson


  type lessonCountArgs = Merge<
    Omit<lessonFindManyArgs, 'select' | 'include'> & {
      select?: LessonCountAggregateInputType | true
    }
  >

  export interface lessonDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {lessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lessonFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, lessonFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'lesson'> extends True ? CheckSelect<T, Prisma__lessonClient<lesson>, Prisma__lessonClient<lessonGetPayload<T>>> : CheckSelect<T, Prisma__lessonClient<lesson | null >, Prisma__lessonClient<lessonGetPayload<T> | null >>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lessonFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, lessonFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'lesson'> extends True ? CheckSelect<T, Prisma__lessonClient<lesson>, Prisma__lessonClient<lessonGetPayload<T>>> : CheckSelect<T, Prisma__lessonClient<lesson | null >, Prisma__lessonClient<lessonGetPayload<T> | null >>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends lessonFindManyArgs>(
      args?: SelectSubset<T, lessonFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<lesson>>, PrismaPromise<Array<lessonGetPayload<T>>>>

    /**
     * Create a Lesson.
     * @param {lessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
    **/
    create<T extends lessonCreateArgs>(
      args: SelectSubset<T, lessonCreateArgs>
    ): CheckSelect<T, Prisma__lessonClient<lesson>, Prisma__lessonClient<lessonGetPayload<T>>>

    /**
     * Create many Lessons.
     *     @param {lessonCreateManyArgs} args - Arguments to create many Lessons.
     *     @example
     *     // Create many Lessons
     *     const lesson = await prisma.lesson.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lessonCreateManyArgs>(
      args?: SelectSubset<T, lessonCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Lesson.
     * @param {lessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
    **/
    delete<T extends lessonDeleteArgs>(
      args: SelectSubset<T, lessonDeleteArgs>
    ): CheckSelect<T, Prisma__lessonClient<lesson>, Prisma__lessonClient<lessonGetPayload<T>>>

    /**
     * Update one Lesson.
     * @param {lessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lessonUpdateArgs>(
      args: SelectSubset<T, lessonUpdateArgs>
    ): CheckSelect<T, Prisma__lessonClient<lesson>, Prisma__lessonClient<lessonGetPayload<T>>>

    /**
     * Delete zero or more Lessons.
     * @param {lessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lessonDeleteManyArgs>(
      args?: SelectSubset<T, lessonDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lessonUpdateManyArgs>(
      args: SelectSubset<T, lessonUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Lesson.
     * @param {lessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
    **/
    upsert<T extends lessonUpsertArgs>(
      args: SelectSubset<T, lessonUpsertArgs>
    ): CheckSelect<T, Prisma__lessonClient<lesson>, Prisma__lessonClient<lessonGetPayload<T>>>

    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends lessonCountArgs>(
      args?: Subset<T, lessonCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__lessonClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    module<T extends moduleArgs = {}>(args?: Subset<T, moduleArgs>): CheckSelect<T, Prisma__moduleClient<module | null >, Prisma__moduleClient<moduleGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * lesson findUnique
   */
  export type lessonFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the lesson
     * 
    **/
    select?: lessonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: lessonInclude | null
    /**
     * Throw an Error if a lesson can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which lesson to fetch.
     * 
    **/
    where: lessonWhereUniqueInput
  }


  /**
   * lesson findFirst
   */
  export type lessonFindFirstArgs = {
    /**
     * Select specific fields to fetch from the lesson
     * 
    **/
    select?: lessonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: lessonInclude | null
    /**
     * Throw an Error if a lesson can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which lesson to fetch.
     * 
    **/
    where?: lessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     * 
    **/
    orderBy?: Enumerable<lessonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lessons.
     * 
    **/
    cursor?: lessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lessons.
     * 
    **/
    distinct?: Enumerable<LessonScalarFieldEnum>
  }


  /**
   * lesson findMany
   */
  export type lessonFindManyArgs = {
    /**
     * Select specific fields to fetch from the lesson
     * 
    **/
    select?: lessonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: lessonInclude | null
    /**
     * Filter, which lessons to fetch.
     * 
    **/
    where?: lessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     * 
    **/
    orderBy?: Enumerable<lessonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lessons.
     * 
    **/
    cursor?: lessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LessonScalarFieldEnum>
  }


  /**
   * lesson create
   */
  export type lessonCreateArgs = {
    /**
     * Select specific fields to fetch from the lesson
     * 
    **/
    select?: lessonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: lessonInclude | null
    /**
     * The data needed to create a lesson.
     * 
    **/
    data: XOR<lessonCreateInput, lessonUncheckedCreateInput>
  }


  /**
   * lesson createMany
   */
  export type lessonCreateManyArgs = {
    /**
     * The data used to create many lessons.
     * 
    **/
    data: Enumerable<lessonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * lesson update
   */
  export type lessonUpdateArgs = {
    /**
     * Select specific fields to fetch from the lesson
     * 
    **/
    select?: lessonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: lessonInclude | null
    /**
     * The data needed to update a lesson.
     * 
    **/
    data: XOR<lessonUpdateInput, lessonUncheckedUpdateInput>
    /**
     * Choose, which lesson to update.
     * 
    **/
    where: lessonWhereUniqueInput
  }


  /**
   * lesson updateMany
   */
  export type lessonUpdateManyArgs = {
    /**
     * The data used to update lessons.
     * 
    **/
    data: XOR<lessonUpdateManyMutationInput, lessonUncheckedUpdateManyInput>
    /**
     * Filter which lessons to update
     * 
    **/
    where?: lessonWhereInput
  }


  /**
   * lesson upsert
   */
  export type lessonUpsertArgs = {
    /**
     * Select specific fields to fetch from the lesson
     * 
    **/
    select?: lessonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: lessonInclude | null
    /**
     * The filter to search for the lesson to update in case it exists.
     * 
    **/
    where: lessonWhereUniqueInput
    /**
     * In case the lesson found by the `where` argument doesn't exist, create a new lesson with this data.
     * 
    **/
    create: XOR<lessonCreateInput, lessonUncheckedCreateInput>
    /**
     * In case the lesson was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<lessonUpdateInput, lessonUncheckedUpdateInput>
  }


  /**
   * lesson delete
   */
  export type lessonDeleteArgs = {
    /**
     * Select specific fields to fetch from the lesson
     * 
    **/
    select?: lessonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: lessonInclude | null
    /**
     * Filter which lesson to delete.
     * 
    **/
    where: lessonWhereUniqueInput
  }


  /**
   * lesson deleteMany
   */
  export type lessonDeleteManyArgs = {
    /**
     * Filter which lessons to delete
     * 
    **/
    where?: lessonWhereInput
  }


  /**
   * lesson without action
   */
  export type lessonArgs = {
    /**
     * Select specific fields to fetch from the lesson
     * 
    **/
    select?: lessonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: lessonInclude | null
  }



  /**
   * Model module
   */


  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    author: string | null
    module_subject_id: string | null
    module_name: string | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    author: string | null
    module_subject_id: string | null
    module_name: string | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    author: number
    module_subject_id: number
    module_name: number
    _all: number
  }


  export type ModuleMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    author?: true
    module_subject_id?: true
    module_name?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    author?: true
    module_subject_id?: true
    module_name?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    author?: true
    module_subject_id?: true
    module_name?: true
    _all?: true
  }

  export type ModuleAggregateArgs = {
    /**
     * Filter which module to aggregate.
     * 
    **/
    where?: moduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modules to fetch.
     * 
    **/
    orderBy?: Enumerable<moduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: moduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs = {
    where?: moduleWhereInput
    orderBy?: Enumerable<moduleOrderByWithAggregationInput>
    by: Array<ModuleScalarFieldEnum>
    having?: moduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }


  export type ModuleGroupByOutputType = {
    id: string
    created_at: Date | null
    updated_at: Date | null
    author: string | null
    module_subject_id: string | null
    module_name: string
    _count: ModuleCountAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type moduleSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    author?: boolean
    module_subject_id?: boolean
    module_name?: boolean
    subject?: boolean | subjectArgs
    lesson?: boolean | lessonFindManyArgs
    student_module?: boolean | student_moduleFindManyArgs
    _count?: boolean | ModuleCountOutputTypeArgs
  }

  export type moduleInclude = {
    subject?: boolean | subjectArgs
    lesson?: boolean | lessonFindManyArgs
    student_module?: boolean | student_moduleFindManyArgs
    _count?: boolean | ModuleCountOutputTypeArgs
  }

  export type moduleGetPayload<
    S extends boolean | null | undefined | moduleArgs,
    U = keyof S
      > = S extends true
        ? module
    : S extends undefined
    ? never
    : S extends moduleArgs | moduleFindManyArgs
    ?'include' extends U
    ? module  & {
    [P in TrueKeys<S['include']>]:
        P extends 'subject' ? subjectGetPayload<S['include'][P]> | null :
        P extends 'lesson' ? Array < lessonGetPayload<S['include'][P]>>  :
        P extends 'student_module' ? Array < student_moduleGetPayload<S['include'][P]>>  :
        P extends '_count' ? ModuleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'subject' ? subjectGetPayload<S['select'][P]> | null :
        P extends 'lesson' ? Array < lessonGetPayload<S['select'][P]>>  :
        P extends 'student_module' ? Array < student_moduleGetPayload<S['select'][P]>>  :
        P extends '_count' ? ModuleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof module ? module[P] : never
  } 
    : module
  : module


  type moduleCountArgs = Merge<
    Omit<moduleFindManyArgs, 'select' | 'include'> & {
      select?: ModuleCountAggregateInputType | true
    }
  >

  export interface moduleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Module that matches the filter.
     * @param {moduleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends moduleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, moduleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'module'> extends True ? CheckSelect<T, Prisma__moduleClient<module>, Prisma__moduleClient<moduleGetPayload<T>>> : CheckSelect<T, Prisma__moduleClient<module | null >, Prisma__moduleClient<moduleGetPayload<T> | null >>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends moduleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, moduleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'module'> extends True ? CheckSelect<T, Prisma__moduleClient<module>, Prisma__moduleClient<moduleGetPayload<T>>> : CheckSelect<T, Prisma__moduleClient<module | null >, Prisma__moduleClient<moduleGetPayload<T> | null >>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends moduleFindManyArgs>(
      args?: SelectSubset<T, moduleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<module>>, PrismaPromise<Array<moduleGetPayload<T>>>>

    /**
     * Create a Module.
     * @param {moduleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
    **/
    create<T extends moduleCreateArgs>(
      args: SelectSubset<T, moduleCreateArgs>
    ): CheckSelect<T, Prisma__moduleClient<module>, Prisma__moduleClient<moduleGetPayload<T>>>

    /**
     * Create many Modules.
     *     @param {moduleCreateManyArgs} args - Arguments to create many Modules.
     *     @example
     *     // Create many Modules
     *     const module = await prisma.module.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends moduleCreateManyArgs>(
      args?: SelectSubset<T, moduleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Module.
     * @param {moduleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
    **/
    delete<T extends moduleDeleteArgs>(
      args: SelectSubset<T, moduleDeleteArgs>
    ): CheckSelect<T, Prisma__moduleClient<module>, Prisma__moduleClient<moduleGetPayload<T>>>

    /**
     * Update one Module.
     * @param {moduleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends moduleUpdateArgs>(
      args: SelectSubset<T, moduleUpdateArgs>
    ): CheckSelect<T, Prisma__moduleClient<module>, Prisma__moduleClient<moduleGetPayload<T>>>

    /**
     * Delete zero or more Modules.
     * @param {moduleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends moduleDeleteManyArgs>(
      args?: SelectSubset<T, moduleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends moduleUpdateManyArgs>(
      args: SelectSubset<T, moduleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Module.
     * @param {moduleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
    **/
    upsert<T extends moduleUpsertArgs>(
      args: SelectSubset<T, moduleUpsertArgs>
    ): CheckSelect<T, Prisma__moduleClient<module>, Prisma__moduleClient<moduleGetPayload<T>>>

    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moduleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends moduleCountArgs>(
      args?: Subset<T, moduleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__moduleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    subject<T extends subjectArgs = {}>(args?: Subset<T, subjectArgs>): CheckSelect<T, Prisma__subjectClient<subject | null >, Prisma__subjectClient<subjectGetPayload<T> | null >>;

    lesson<T extends lessonFindManyArgs = {}>(args?: Subset<T, lessonFindManyArgs>): CheckSelect<T, PrismaPromise<Array<lesson>>, PrismaPromise<Array<lessonGetPayload<T>>>>;

    student_module<T extends student_moduleFindManyArgs = {}>(args?: Subset<T, student_moduleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<student_module>>, PrismaPromise<Array<student_moduleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * module findUnique
   */
  export type moduleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the module
     * 
    **/
    select?: moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: moduleInclude | null
    /**
     * Throw an Error if a module can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which module to fetch.
     * 
    **/
    where: moduleWhereUniqueInput
  }


  /**
   * module findFirst
   */
  export type moduleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the module
     * 
    **/
    select?: moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: moduleInclude | null
    /**
     * Throw an Error if a module can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which module to fetch.
     * 
    **/
    where?: moduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modules to fetch.
     * 
    **/
    orderBy?: Enumerable<moduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modules.
     * 
    **/
    cursor?: moduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modules.
     * 
    **/
    distinct?: Enumerable<ModuleScalarFieldEnum>
  }


  /**
   * module findMany
   */
  export type moduleFindManyArgs = {
    /**
     * Select specific fields to fetch from the module
     * 
    **/
    select?: moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: moduleInclude | null
    /**
     * Filter, which modules to fetch.
     * 
    **/
    where?: moduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modules to fetch.
     * 
    **/
    orderBy?: Enumerable<moduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing modules.
     * 
    **/
    cursor?: moduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ModuleScalarFieldEnum>
  }


  /**
   * module create
   */
  export type moduleCreateArgs = {
    /**
     * Select specific fields to fetch from the module
     * 
    **/
    select?: moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: moduleInclude | null
    /**
     * The data needed to create a module.
     * 
    **/
    data: XOR<moduleCreateInput, moduleUncheckedCreateInput>
  }


  /**
   * module createMany
   */
  export type moduleCreateManyArgs = {
    /**
     * The data used to create many modules.
     * 
    **/
    data: Enumerable<moduleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * module update
   */
  export type moduleUpdateArgs = {
    /**
     * Select specific fields to fetch from the module
     * 
    **/
    select?: moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: moduleInclude | null
    /**
     * The data needed to update a module.
     * 
    **/
    data: XOR<moduleUpdateInput, moduleUncheckedUpdateInput>
    /**
     * Choose, which module to update.
     * 
    **/
    where: moduleWhereUniqueInput
  }


  /**
   * module updateMany
   */
  export type moduleUpdateManyArgs = {
    /**
     * The data used to update modules.
     * 
    **/
    data: XOR<moduleUpdateManyMutationInput, moduleUncheckedUpdateManyInput>
    /**
     * Filter which modules to update
     * 
    **/
    where?: moduleWhereInput
  }


  /**
   * module upsert
   */
  export type moduleUpsertArgs = {
    /**
     * Select specific fields to fetch from the module
     * 
    **/
    select?: moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: moduleInclude | null
    /**
     * The filter to search for the module to update in case it exists.
     * 
    **/
    where: moduleWhereUniqueInput
    /**
     * In case the module found by the `where` argument doesn't exist, create a new module with this data.
     * 
    **/
    create: XOR<moduleCreateInput, moduleUncheckedCreateInput>
    /**
     * In case the module was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<moduleUpdateInput, moduleUncheckedUpdateInput>
  }


  /**
   * module delete
   */
  export type moduleDeleteArgs = {
    /**
     * Select specific fields to fetch from the module
     * 
    **/
    select?: moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: moduleInclude | null
    /**
     * Filter which module to delete.
     * 
    **/
    where: moduleWhereUniqueInput
  }


  /**
   * module deleteMany
   */
  export type moduleDeleteManyArgs = {
    /**
     * Filter which modules to delete
     * 
    **/
    where?: moduleWhereInput
  }


  /**
   * module without action
   */
  export type moduleArgs = {
    /**
     * Select specific fields to fetch from the module
     * 
    **/
    select?: moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: moduleInclude | null
  }



  /**
   * Model question_topic
   */


  export type AggregateQuestion_topic = {
    _count: Question_topicCountAggregateOutputType | null
    _min: Question_topicMinAggregateOutputType | null
    _max: Question_topicMaxAggregateOutputType | null
  }

  export type Question_topicMinAggregateOutputType = {
    id: string | null
    topic_id: string | null
    question_id: string | null
  }

  export type Question_topicMaxAggregateOutputType = {
    id: string | null
    topic_id: string | null
    question_id: string | null
  }

  export type Question_topicCountAggregateOutputType = {
    id: number
    topic_id: number
    question_id: number
    _all: number
  }


  export type Question_topicMinAggregateInputType = {
    id?: true
    topic_id?: true
    question_id?: true
  }

  export type Question_topicMaxAggregateInputType = {
    id?: true
    topic_id?: true
    question_id?: true
  }

  export type Question_topicCountAggregateInputType = {
    id?: true
    topic_id?: true
    question_id?: true
    _all?: true
  }

  export type Question_topicAggregateArgs = {
    /**
     * Filter which question_topic to aggregate.
     * 
    **/
    where?: question_topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_topics to fetch.
     * 
    **/
    orderBy?: Enumerable<question_topicOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: question_topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_topics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_topics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned question_topics
    **/
    _count?: true | Question_topicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Question_topicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Question_topicMaxAggregateInputType
  }

  export type GetQuestion_topicAggregateType<T extends Question_topicAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion_topic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion_topic[P]>
      : GetScalarType<T[P], AggregateQuestion_topic[P]>
  }




  export type Question_topicGroupByArgs = {
    where?: question_topicWhereInput
    orderBy?: Enumerable<question_topicOrderByWithAggregationInput>
    by: Array<Question_topicScalarFieldEnum>
    having?: question_topicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Question_topicCountAggregateInputType | true
    _min?: Question_topicMinAggregateInputType
    _max?: Question_topicMaxAggregateInputType
  }


  export type Question_topicGroupByOutputType = {
    id: string
    topic_id: string
    question_id: string | null
    _count: Question_topicCountAggregateOutputType | null
    _min: Question_topicMinAggregateOutputType | null
    _max: Question_topicMaxAggregateOutputType | null
  }

  type GetQuestion_topicGroupByPayload<T extends Question_topicGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Question_topicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Question_topicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Question_topicGroupByOutputType[P]>
            : GetScalarType<T[P], Question_topicGroupByOutputType[P]>
        }
      >
    >


  export type question_topicSelect = {
    id?: boolean
    topic_id?: boolean
    question_id?: boolean
    question?: boolean | questionArgs
    topic?: boolean | topicArgs
  }

  export type question_topicInclude = {
    question?: boolean | questionArgs
    topic?: boolean | topicArgs
  }

  export type question_topicGetPayload<
    S extends boolean | null | undefined | question_topicArgs,
    U = keyof S
      > = S extends true
        ? question_topic
    : S extends undefined
    ? never
    : S extends question_topicArgs | question_topicFindManyArgs
    ?'include' extends U
    ? question_topic  & {
    [P in TrueKeys<S['include']>]:
        P extends 'question' ? questionGetPayload<S['include'][P]> | null :
        P extends 'topic' ? topicGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'question' ? questionGetPayload<S['select'][P]> | null :
        P extends 'topic' ? topicGetPayload<S['select'][P]> :  P extends keyof question_topic ? question_topic[P] : never
  } 
    : question_topic
  : question_topic


  type question_topicCountArgs = Merge<
    Omit<question_topicFindManyArgs, 'select' | 'include'> & {
      select?: Question_topicCountAggregateInputType | true
    }
  >

  export interface question_topicDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Question_topic that matches the filter.
     * @param {question_topicFindUniqueArgs} args - Arguments to find a Question_topic
     * @example
     * // Get one Question_topic
     * const question_topic = await prisma.question_topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends question_topicFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, question_topicFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'question_topic'> extends True ? CheckSelect<T, Prisma__question_topicClient<question_topic>, Prisma__question_topicClient<question_topicGetPayload<T>>> : CheckSelect<T, Prisma__question_topicClient<question_topic | null >, Prisma__question_topicClient<question_topicGetPayload<T> | null >>

    /**
     * Find the first Question_topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_topicFindFirstArgs} args - Arguments to find a Question_topic
     * @example
     * // Get one Question_topic
     * const question_topic = await prisma.question_topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends question_topicFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, question_topicFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'question_topic'> extends True ? CheckSelect<T, Prisma__question_topicClient<question_topic>, Prisma__question_topicClient<question_topicGetPayload<T>>> : CheckSelect<T, Prisma__question_topicClient<question_topic | null >, Prisma__question_topicClient<question_topicGetPayload<T> | null >>

    /**
     * Find zero or more Question_topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_topicFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Question_topics
     * const question_topics = await prisma.question_topic.findMany()
     * 
     * // Get first 10 Question_topics
     * const question_topics = await prisma.question_topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const question_topicWithIdOnly = await prisma.question_topic.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends question_topicFindManyArgs>(
      args?: SelectSubset<T, question_topicFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<question_topic>>, PrismaPromise<Array<question_topicGetPayload<T>>>>

    /**
     * Create a Question_topic.
     * @param {question_topicCreateArgs} args - Arguments to create a Question_topic.
     * @example
     * // Create one Question_topic
     * const Question_topic = await prisma.question_topic.create({
     *   data: {
     *     // ... data to create a Question_topic
     *   }
     * })
     * 
    **/
    create<T extends question_topicCreateArgs>(
      args: SelectSubset<T, question_topicCreateArgs>
    ): CheckSelect<T, Prisma__question_topicClient<question_topic>, Prisma__question_topicClient<question_topicGetPayload<T>>>

    /**
     * Create many Question_topics.
     *     @param {question_topicCreateManyArgs} args - Arguments to create many Question_topics.
     *     @example
     *     // Create many Question_topics
     *     const question_topic = await prisma.question_topic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends question_topicCreateManyArgs>(
      args?: SelectSubset<T, question_topicCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Question_topic.
     * @param {question_topicDeleteArgs} args - Arguments to delete one Question_topic.
     * @example
     * // Delete one Question_topic
     * const Question_topic = await prisma.question_topic.delete({
     *   where: {
     *     // ... filter to delete one Question_topic
     *   }
     * })
     * 
    **/
    delete<T extends question_topicDeleteArgs>(
      args: SelectSubset<T, question_topicDeleteArgs>
    ): CheckSelect<T, Prisma__question_topicClient<question_topic>, Prisma__question_topicClient<question_topicGetPayload<T>>>

    /**
     * Update one Question_topic.
     * @param {question_topicUpdateArgs} args - Arguments to update one Question_topic.
     * @example
     * // Update one Question_topic
     * const question_topic = await prisma.question_topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends question_topicUpdateArgs>(
      args: SelectSubset<T, question_topicUpdateArgs>
    ): CheckSelect<T, Prisma__question_topicClient<question_topic>, Prisma__question_topicClient<question_topicGetPayload<T>>>

    /**
     * Delete zero or more Question_topics.
     * @param {question_topicDeleteManyArgs} args - Arguments to filter Question_topics to delete.
     * @example
     * // Delete a few Question_topics
     * const { count } = await prisma.question_topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends question_topicDeleteManyArgs>(
      args?: SelectSubset<T, question_topicDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Question_topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_topicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Question_topics
     * const question_topic = await prisma.question_topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends question_topicUpdateManyArgs>(
      args: SelectSubset<T, question_topicUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Question_topic.
     * @param {question_topicUpsertArgs} args - Arguments to update or create a Question_topic.
     * @example
     * // Update or create a Question_topic
     * const question_topic = await prisma.question_topic.upsert({
     *   create: {
     *     // ... data to create a Question_topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question_topic we want to update
     *   }
     * })
    **/
    upsert<T extends question_topicUpsertArgs>(
      args: SelectSubset<T, question_topicUpsertArgs>
    ): CheckSelect<T, Prisma__question_topicClient<question_topic>, Prisma__question_topicClient<question_topicGetPayload<T>>>

    /**
     * Count the number of Question_topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_topicCountArgs} args - Arguments to filter Question_topics to count.
     * @example
     * // Count the number of Question_topics
     * const count = await prisma.question_topic.count({
     *   where: {
     *     // ... the filter for the Question_topics we want to count
     *   }
     * })
    **/
    count<T extends question_topicCountArgs>(
      args?: Subset<T, question_topicCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Question_topicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question_topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Question_topicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Question_topicAggregateArgs>(args: Subset<T, Question_topicAggregateArgs>): PrismaPromise<GetQuestion_topicAggregateType<T>>

    /**
     * Group by Question_topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Question_topicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Question_topicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Question_topicGroupByArgs['orderBy'] }
        : { orderBy?: Question_topicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Question_topicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestion_topicGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for question_topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__question_topicClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    question<T extends questionArgs = {}>(args?: Subset<T, questionArgs>): CheckSelect<T, Prisma__questionClient<question | null >, Prisma__questionClient<questionGetPayload<T> | null >>;

    topic<T extends topicArgs = {}>(args?: Subset<T, topicArgs>): CheckSelect<T, Prisma__topicClient<topic | null >, Prisma__topicClient<topicGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * question_topic findUnique
   */
  export type question_topicFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the question_topic
     * 
    **/
    select?: question_topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: question_topicInclude | null
    /**
     * Throw an Error if a question_topic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which question_topic to fetch.
     * 
    **/
    where: question_topicWhereUniqueInput
  }


  /**
   * question_topic findFirst
   */
  export type question_topicFindFirstArgs = {
    /**
     * Select specific fields to fetch from the question_topic
     * 
    **/
    select?: question_topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: question_topicInclude | null
    /**
     * Throw an Error if a question_topic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which question_topic to fetch.
     * 
    **/
    where?: question_topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_topics to fetch.
     * 
    **/
    orderBy?: Enumerable<question_topicOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_topics.
     * 
    **/
    cursor?: question_topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_topics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_topics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_topics.
     * 
    **/
    distinct?: Enumerable<Question_topicScalarFieldEnum>
  }


  /**
   * question_topic findMany
   */
  export type question_topicFindManyArgs = {
    /**
     * Select specific fields to fetch from the question_topic
     * 
    **/
    select?: question_topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: question_topicInclude | null
    /**
     * Filter, which question_topics to fetch.
     * 
    **/
    where?: question_topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_topics to fetch.
     * 
    **/
    orderBy?: Enumerable<question_topicOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing question_topics.
     * 
    **/
    cursor?: question_topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_topics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_topics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Question_topicScalarFieldEnum>
  }


  /**
   * question_topic create
   */
  export type question_topicCreateArgs = {
    /**
     * Select specific fields to fetch from the question_topic
     * 
    **/
    select?: question_topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: question_topicInclude | null
    /**
     * The data needed to create a question_topic.
     * 
    **/
    data: XOR<question_topicCreateInput, question_topicUncheckedCreateInput>
  }


  /**
   * question_topic createMany
   */
  export type question_topicCreateManyArgs = {
    /**
     * The data used to create many question_topics.
     * 
    **/
    data: Enumerable<question_topicCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * question_topic update
   */
  export type question_topicUpdateArgs = {
    /**
     * Select specific fields to fetch from the question_topic
     * 
    **/
    select?: question_topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: question_topicInclude | null
    /**
     * The data needed to update a question_topic.
     * 
    **/
    data: XOR<question_topicUpdateInput, question_topicUncheckedUpdateInput>
    /**
     * Choose, which question_topic to update.
     * 
    **/
    where: question_topicWhereUniqueInput
  }


  /**
   * question_topic updateMany
   */
  export type question_topicUpdateManyArgs = {
    /**
     * The data used to update question_topics.
     * 
    **/
    data: XOR<question_topicUpdateManyMutationInput, question_topicUncheckedUpdateManyInput>
    /**
     * Filter which question_topics to update
     * 
    **/
    where?: question_topicWhereInput
  }


  /**
   * question_topic upsert
   */
  export type question_topicUpsertArgs = {
    /**
     * Select specific fields to fetch from the question_topic
     * 
    **/
    select?: question_topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: question_topicInclude | null
    /**
     * The filter to search for the question_topic to update in case it exists.
     * 
    **/
    where: question_topicWhereUniqueInput
    /**
     * In case the question_topic found by the `where` argument doesn't exist, create a new question_topic with this data.
     * 
    **/
    create: XOR<question_topicCreateInput, question_topicUncheckedCreateInput>
    /**
     * In case the question_topic was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<question_topicUpdateInput, question_topicUncheckedUpdateInput>
  }


  /**
   * question_topic delete
   */
  export type question_topicDeleteArgs = {
    /**
     * Select specific fields to fetch from the question_topic
     * 
    **/
    select?: question_topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: question_topicInclude | null
    /**
     * Filter which question_topic to delete.
     * 
    **/
    where: question_topicWhereUniqueInput
  }


  /**
   * question_topic deleteMany
   */
  export type question_topicDeleteManyArgs = {
    /**
     * Filter which question_topics to delete
     * 
    **/
    where?: question_topicWhereInput
  }


  /**
   * question_topic without action
   */
  export type question_topicArgs = {
    /**
     * Select specific fields to fetch from the question_topic
     * 
    **/
    select?: question_topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: question_topicInclude | null
  }



  /**
   * Model topic
   */


  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    question_topic_name: string | null
  }

  export type TopicMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    question_topic_name: string | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    question_topic_name: number
    _all: number
  }


  export type TopicMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    question_topic_name?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    question_topic_name?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    question_topic_name?: true
    _all?: true
  }

  export type TopicAggregateArgs = {
    /**
     * Filter which topic to aggregate.
     * 
    **/
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     * 
    **/
    orderBy?: Enumerable<topicOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs = {
    where?: topicWhereInput
    orderBy?: Enumerable<topicOrderByWithAggregationInput>
    by: Array<TopicScalarFieldEnum>
    having?: topicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }


  export type TopicGroupByOutputType = {
    id: string
    created_at: Date | null
    updated_at: Date | null
    question_topic_name: string
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type topicSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    question_topic_name?: boolean
    question_topic?: boolean | question_topicFindManyArgs
    _count?: boolean | TopicCountOutputTypeArgs
  }

  export type topicInclude = {
    question_topic?: boolean | question_topicFindManyArgs
    _count?: boolean | TopicCountOutputTypeArgs
  }

  export type topicGetPayload<
    S extends boolean | null | undefined | topicArgs,
    U = keyof S
      > = S extends true
        ? topic
    : S extends undefined
    ? never
    : S extends topicArgs | topicFindManyArgs
    ?'include' extends U
    ? topic  & {
    [P in TrueKeys<S['include']>]:
        P extends 'question_topic' ? Array < question_topicGetPayload<S['include'][P]>>  :
        P extends '_count' ? TopicCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'question_topic' ? Array < question_topicGetPayload<S['select'][P]>>  :
        P extends '_count' ? TopicCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof topic ? topic[P] : never
  } 
    : topic
  : topic


  type topicCountArgs = Merge<
    Omit<topicFindManyArgs, 'select' | 'include'> & {
      select?: TopicCountAggregateInputType | true
    }
  >

  export interface topicDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Topic that matches the filter.
     * @param {topicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends topicFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, topicFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'topic'> extends True ? CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>> : CheckSelect<T, Prisma__topicClient<topic | null >, Prisma__topicClient<topicGetPayload<T> | null >>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends topicFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, topicFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'topic'> extends True ? CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>> : CheckSelect<T, Prisma__topicClient<topic | null >, Prisma__topicClient<topicGetPayload<T> | null >>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends topicFindManyArgs>(
      args?: SelectSubset<T, topicFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<topic>>, PrismaPromise<Array<topicGetPayload<T>>>>

    /**
     * Create a Topic.
     * @param {topicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
    **/
    create<T extends topicCreateArgs>(
      args: SelectSubset<T, topicCreateArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Create many Topics.
     *     @param {topicCreateManyArgs} args - Arguments to create many Topics.
     *     @example
     *     // Create many Topics
     *     const topic = await prisma.topic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends topicCreateManyArgs>(
      args?: SelectSubset<T, topicCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Topic.
     * @param {topicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
    **/
    delete<T extends topicDeleteArgs>(
      args: SelectSubset<T, topicDeleteArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Update one Topic.
     * @param {topicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends topicUpdateArgs>(
      args: SelectSubset<T, topicUpdateArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Delete zero or more Topics.
     * @param {topicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends topicDeleteManyArgs>(
      args?: SelectSubset<T, topicDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends topicUpdateManyArgs>(
      args: SelectSubset<T, topicUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {topicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
    **/
    upsert<T extends topicUpsertArgs>(
      args: SelectSubset<T, topicUpsertArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends topicCountArgs>(
      args?: Subset<T, topicCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__topicClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    question_topic<T extends question_topicFindManyArgs = {}>(args?: Subset<T, question_topicFindManyArgs>): CheckSelect<T, PrismaPromise<Array<question_topic>>, PrismaPromise<Array<question_topicGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * topic findUnique
   */
  export type topicFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * Throw an Error if a topic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which topic to fetch.
     * 
    **/
    where: topicWhereUniqueInput
  }


  /**
   * topic findFirst
   */
  export type topicFindFirstArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * Throw an Error if a topic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which topic to fetch.
     * 
    **/
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     * 
    **/
    orderBy?: Enumerable<topicOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for topics.
     * 
    **/
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of topics.
     * 
    **/
    distinct?: Enumerable<TopicScalarFieldEnum>
  }


  /**
   * topic findMany
   */
  export type topicFindManyArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * Filter, which topics to fetch.
     * 
    **/
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     * 
    **/
    orderBy?: Enumerable<topicOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing topics.
     * 
    **/
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TopicScalarFieldEnum>
  }


  /**
   * topic create
   */
  export type topicCreateArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * The data needed to create a topic.
     * 
    **/
    data: XOR<topicCreateInput, topicUncheckedCreateInput>
  }


  /**
   * topic createMany
   */
  export type topicCreateManyArgs = {
    /**
     * The data used to create many topics.
     * 
    **/
    data: Enumerable<topicCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * topic update
   */
  export type topicUpdateArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * The data needed to update a topic.
     * 
    **/
    data: XOR<topicUpdateInput, topicUncheckedUpdateInput>
    /**
     * Choose, which topic to update.
     * 
    **/
    where: topicWhereUniqueInput
  }


  /**
   * topic updateMany
   */
  export type topicUpdateManyArgs = {
    /**
     * The data used to update topics.
     * 
    **/
    data: XOR<topicUpdateManyMutationInput, topicUncheckedUpdateManyInput>
    /**
     * Filter which topics to update
     * 
    **/
    where?: topicWhereInput
  }


  /**
   * topic upsert
   */
  export type topicUpsertArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * The filter to search for the topic to update in case it exists.
     * 
    **/
    where: topicWhereUniqueInput
    /**
     * In case the topic found by the `where` argument doesn't exist, create a new topic with this data.
     * 
    **/
    create: XOR<topicCreateInput, topicUncheckedCreateInput>
    /**
     * In case the topic was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<topicUpdateInput, topicUncheckedUpdateInput>
  }


  /**
   * topic delete
   */
  export type topicDeleteArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * Filter which topic to delete.
     * 
    **/
    where: topicWhereUniqueInput
  }


  /**
   * topic deleteMany
   */
  export type topicDeleteManyArgs = {
    /**
     * Filter which topics to delete
     * 
    **/
    where?: topicWhereInput
  }


  /**
   * topic without action
   */
  export type topicArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
  }



  /**
   * Model question
   */


  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    difficulty: number | null
  }

  export type QuestionSumAggregateOutputType = {
    difficulty: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    difficulty: number | null
    image_url: string | null
    equation: string | null
    question_text: string | null
    answer_formula: string | null
    updated_at: Date | null
    author: string | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    difficulty: number | null
    image_url: string | null
    equation: string | null
    question_text: string | null
    answer_formula: string | null
    updated_at: Date | null
    author: string | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    created_at: number
    difficulty: number
    image_url: number
    equation: number
    question_text: number
    answer_formula: number
    updated_at: number
    author: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    difficulty?: true
  }

  export type QuestionSumAggregateInputType = {
    difficulty?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    created_at?: true
    difficulty?: true
    image_url?: true
    equation?: true
    question_text?: true
    answer_formula?: true
    updated_at?: true
    author?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    created_at?: true
    difficulty?: true
    image_url?: true
    equation?: true
    question_text?: true
    answer_formula?: true
    updated_at?: true
    author?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    created_at?: true
    difficulty?: true
    image_url?: true
    equation?: true
    question_text?: true
    answer_formula?: true
    updated_at?: true
    author?: true
    _all?: true
  }

  export type QuestionAggregateArgs = {
    /**
     * Filter which question to aggregate.
     * 
    **/
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     * 
    **/
    orderBy?: Enumerable<questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs = {
    where?: questionWhereInput
    orderBy?: Enumerable<questionOrderByWithAggregationInput>
    by: Array<QuestionScalarFieldEnum>
    having?: questionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }


  export type QuestionGroupByOutputType = {
    id: string
    created_at: Date | null
    difficulty: number | null
    image_url: string | null
    equation: string | null
    question_text: string | null
    answer_formula: string | null
    updated_at: Date | null
    author: string | null
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type questionSelect = {
    id?: boolean
    created_at?: boolean
    difficulty?: boolean
    image_url?: boolean
    equation?: boolean
    question_text?: boolean
    answer_formula?: boolean
    updated_at?: boolean
    author?: boolean
    question_topic?: boolean | question_topicFindManyArgs
    _count?: boolean | QuestionCountOutputTypeArgs
  }

  export type questionInclude = {
    question_topic?: boolean | question_topicFindManyArgs
    _count?: boolean | QuestionCountOutputTypeArgs
  }

  export type questionGetPayload<
    S extends boolean | null | undefined | questionArgs,
    U = keyof S
      > = S extends true
        ? question
    : S extends undefined
    ? never
    : S extends questionArgs | questionFindManyArgs
    ?'include' extends U
    ? question  & {
    [P in TrueKeys<S['include']>]:
        P extends 'question_topic' ? Array < question_topicGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuestionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'question_topic' ? Array < question_topicGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuestionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof question ? question[P] : never
  } 
    : question
  : question


  type questionCountArgs = Merge<
    Omit<questionFindManyArgs, 'select' | 'include'> & {
      select?: QuestionCountAggregateInputType | true
    }
  >

  export interface questionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Question that matches the filter.
     * @param {questionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends questionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, questionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'question'> extends True ? CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>> : CheckSelect<T, Prisma__questionClient<question | null >, Prisma__questionClient<questionGetPayload<T> | null >>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends questionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, questionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'question'> extends True ? CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>> : CheckSelect<T, Prisma__questionClient<question | null >, Prisma__questionClient<questionGetPayload<T> | null >>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends questionFindManyArgs>(
      args?: SelectSubset<T, questionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<question>>, PrismaPromise<Array<questionGetPayload<T>>>>

    /**
     * Create a Question.
     * @param {questionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
    **/
    create<T extends questionCreateArgs>(
      args: SelectSubset<T, questionCreateArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Create many Questions.
     *     @param {questionCreateManyArgs} args - Arguments to create many Questions.
     *     @example
     *     // Create many Questions
     *     const question = await prisma.question.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends questionCreateManyArgs>(
      args?: SelectSubset<T, questionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Question.
     * @param {questionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
    **/
    delete<T extends questionDeleteArgs>(
      args: SelectSubset<T, questionDeleteArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Update one Question.
     * @param {questionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends questionUpdateArgs>(
      args: SelectSubset<T, questionUpdateArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Delete zero or more Questions.
     * @param {questionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends questionDeleteManyArgs>(
      args?: SelectSubset<T, questionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends questionUpdateManyArgs>(
      args: SelectSubset<T, questionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {questionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
    **/
    upsert<T extends questionUpsertArgs>(
      args: SelectSubset<T, questionUpsertArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionCountArgs>(
      args?: Subset<T, questionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__questionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    question_topic<T extends question_topicFindManyArgs = {}>(args?: Subset<T, question_topicFindManyArgs>): CheckSelect<T, PrismaPromise<Array<question_topic>>, PrismaPromise<Array<question_topicGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * question findUnique
   */
  export type questionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * Throw an Error if a question can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which question to fetch.
     * 
    **/
    where: questionWhereUniqueInput
  }


  /**
   * question findFirst
   */
  export type questionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * Throw an Error if a question can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which question to fetch.
     * 
    **/
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     * 
    **/
    orderBy?: Enumerable<questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     * 
    **/
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     * 
    **/
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }


  /**
   * question findMany
   */
  export type questionFindManyArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * Filter, which questions to fetch.
     * 
    **/
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     * 
    **/
    orderBy?: Enumerable<questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     * 
    **/
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }


  /**
   * question create
   */
  export type questionCreateArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * The data needed to create a question.
     * 
    **/
    data: XOR<questionCreateInput, questionUncheckedCreateInput>
  }


  /**
   * question createMany
   */
  export type questionCreateManyArgs = {
    /**
     * The data used to create many questions.
     * 
    **/
    data: Enumerable<questionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * question update
   */
  export type questionUpdateArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * The data needed to update a question.
     * 
    **/
    data: XOR<questionUpdateInput, questionUncheckedUpdateInput>
    /**
     * Choose, which question to update.
     * 
    **/
    where: questionWhereUniqueInput
  }


  /**
   * question updateMany
   */
  export type questionUpdateManyArgs = {
    /**
     * The data used to update questions.
     * 
    **/
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     * 
    **/
    where?: questionWhereInput
  }


  /**
   * question upsert
   */
  export type questionUpsertArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * The filter to search for the question to update in case it exists.
     * 
    **/
    where: questionWhereUniqueInput
    /**
     * In case the question found by the `where` argument doesn't exist, create a new question with this data.
     * 
    **/
    create: XOR<questionCreateInput, questionUncheckedCreateInput>
    /**
     * In case the question was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<questionUpdateInput, questionUncheckedUpdateInput>
  }


  /**
   * question delete
   */
  export type questionDeleteArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * Filter which question to delete.
     * 
    **/
    where: questionWhereUniqueInput
  }


  /**
   * question deleteMany
   */
  export type questionDeleteManyArgs = {
    /**
     * Filter which questions to delete
     * 
    **/
    where?: questionWhereInput
  }


  /**
   * question without action
   */
  export type questionArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
  }



  /**
   * Model quiz_attempt
   */


  export type AggregateQuiz_attempt = {
    _count: Quiz_attemptCountAggregateOutputType | null
    _avg: Quiz_attemptAvgAggregateOutputType | null
    _sum: Quiz_attemptSumAggregateOutputType | null
    _min: Quiz_attemptMinAggregateOutputType | null
    _max: Quiz_attemptMaxAggregateOutputType | null
  }

  export type Quiz_attemptAvgAggregateOutputType = {
    total_points: number | null
    points_scored: number | null
    question_answered_count: number | null
    question_unanswered_count: number | null
  }

  export type Quiz_attemptSumAggregateOutputType = {
    total_points: number | null
    points_scored: number | null
    question_answered_count: number | null
    question_unanswered_count: number | null
  }

  export type Quiz_attemptMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    student_id: string | null
    quiz_id: string | null
    total_points: number | null
    points_scored: number | null
    enroll_id: string | null
    question_answered_count: number | null
    question_unanswered_count: number | null
  }

  export type Quiz_attemptMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    student_id: string | null
    quiz_id: string | null
    total_points: number | null
    points_scored: number | null
    enroll_id: string | null
    question_answered_count: number | null
    question_unanswered_count: number | null
  }

  export type Quiz_attemptCountAggregateOutputType = {
    id: number
    created_at: number
    student_id: number
    quiz_id: number
    total_points: number
    points_scored: number
    enroll_id: number
    answer_data: number
    question_answered_count: number
    question_unanswered_count: number
    _all: number
  }


  export type Quiz_attemptAvgAggregateInputType = {
    total_points?: true
    points_scored?: true
    question_answered_count?: true
    question_unanswered_count?: true
  }

  export type Quiz_attemptSumAggregateInputType = {
    total_points?: true
    points_scored?: true
    question_answered_count?: true
    question_unanswered_count?: true
  }

  export type Quiz_attemptMinAggregateInputType = {
    id?: true
    created_at?: true
    student_id?: true
    quiz_id?: true
    total_points?: true
    points_scored?: true
    enroll_id?: true
    question_answered_count?: true
    question_unanswered_count?: true
  }

  export type Quiz_attemptMaxAggregateInputType = {
    id?: true
    created_at?: true
    student_id?: true
    quiz_id?: true
    total_points?: true
    points_scored?: true
    enroll_id?: true
    question_answered_count?: true
    question_unanswered_count?: true
  }

  export type Quiz_attemptCountAggregateInputType = {
    id?: true
    created_at?: true
    student_id?: true
    quiz_id?: true
    total_points?: true
    points_scored?: true
    enroll_id?: true
    answer_data?: true
    question_answered_count?: true
    question_unanswered_count?: true
    _all?: true
  }

  export type Quiz_attemptAggregateArgs = {
    /**
     * Filter which quiz_attempt to aggregate.
     * 
    **/
    where?: quiz_attemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_attempts to fetch.
     * 
    **/
    orderBy?: Enumerable<quiz_attemptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: quiz_attemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_attempts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_attempts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quiz_attempts
    **/
    _count?: true | Quiz_attemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Quiz_attemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Quiz_attemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quiz_attemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quiz_attemptMaxAggregateInputType
  }

  export type GetQuiz_attemptAggregateType<T extends Quiz_attemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz_attempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz_attempt[P]>
      : GetScalarType<T[P], AggregateQuiz_attempt[P]>
  }




  export type Quiz_attemptGroupByArgs = {
    where?: quiz_attemptWhereInput
    orderBy?: Enumerable<quiz_attemptOrderByWithAggregationInput>
    by: Array<Quiz_attemptScalarFieldEnum>
    having?: quiz_attemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quiz_attemptCountAggregateInputType | true
    _avg?: Quiz_attemptAvgAggregateInputType
    _sum?: Quiz_attemptSumAggregateInputType
    _min?: Quiz_attemptMinAggregateInputType
    _max?: Quiz_attemptMaxAggregateInputType
  }


  export type Quiz_attemptGroupByOutputType = {
    id: string
    created_at: Date | null
    student_id: string
    quiz_id: string
    total_points: number | null
    points_scored: number | null
    enroll_id: string | null
    answer_data: JsonValue | null
    question_answered_count: number | null
    question_unanswered_count: number | null
    _count: Quiz_attemptCountAggregateOutputType | null
    _avg: Quiz_attemptAvgAggregateOutputType | null
    _sum: Quiz_attemptSumAggregateOutputType | null
    _min: Quiz_attemptMinAggregateOutputType | null
    _max: Quiz_attemptMaxAggregateOutputType | null
  }

  type GetQuiz_attemptGroupByPayload<T extends Quiz_attemptGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Quiz_attemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quiz_attemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quiz_attemptGroupByOutputType[P]>
            : GetScalarType<T[P], Quiz_attemptGroupByOutputType[P]>
        }
      >
    >


  export type quiz_attemptSelect = {
    id?: boolean
    created_at?: boolean
    student_id?: boolean
    quiz_id?: boolean
    total_points?: boolean
    points_scored?: boolean
    enroll_id?: boolean
    answer_data?: boolean
    question_answered_count?: boolean
    question_unanswered_count?: boolean
    enrollment?: boolean | enrollmentArgs
    quiz?: boolean | quizArgs
    student?: boolean | studentArgs
  }

  export type quiz_attemptInclude = {
    enrollment?: boolean | enrollmentArgs
    quiz?: boolean | quizArgs
    student?: boolean | studentArgs
  }

  export type quiz_attemptGetPayload<
    S extends boolean | null | undefined | quiz_attemptArgs,
    U = keyof S
      > = S extends true
        ? quiz_attempt
    : S extends undefined
    ? never
    : S extends quiz_attemptArgs | quiz_attemptFindManyArgs
    ?'include' extends U
    ? quiz_attempt  & {
    [P in TrueKeys<S['include']>]:
        P extends 'enrollment' ? enrollmentGetPayload<S['include'][P]> | null :
        P extends 'quiz' ? quizGetPayload<S['include'][P]> :
        P extends 'student' ? studentGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'enrollment' ? enrollmentGetPayload<S['select'][P]> | null :
        P extends 'quiz' ? quizGetPayload<S['select'][P]> :
        P extends 'student' ? studentGetPayload<S['select'][P]> :  P extends keyof quiz_attempt ? quiz_attempt[P] : never
  } 
    : quiz_attempt
  : quiz_attempt


  type quiz_attemptCountArgs = Merge<
    Omit<quiz_attemptFindManyArgs, 'select' | 'include'> & {
      select?: Quiz_attemptCountAggregateInputType | true
    }
  >

  export interface quiz_attemptDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Quiz_attempt that matches the filter.
     * @param {quiz_attemptFindUniqueArgs} args - Arguments to find a Quiz_attempt
     * @example
     * // Get one Quiz_attempt
     * const quiz_attempt = await prisma.quiz_attempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends quiz_attemptFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, quiz_attemptFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'quiz_attempt'> extends True ? CheckSelect<T, Prisma__quiz_attemptClient<quiz_attempt>, Prisma__quiz_attemptClient<quiz_attemptGetPayload<T>>> : CheckSelect<T, Prisma__quiz_attemptClient<quiz_attempt | null >, Prisma__quiz_attemptClient<quiz_attemptGetPayload<T> | null >>

    /**
     * Find the first Quiz_attempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_attemptFindFirstArgs} args - Arguments to find a Quiz_attempt
     * @example
     * // Get one Quiz_attempt
     * const quiz_attempt = await prisma.quiz_attempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends quiz_attemptFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, quiz_attemptFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'quiz_attempt'> extends True ? CheckSelect<T, Prisma__quiz_attemptClient<quiz_attempt>, Prisma__quiz_attemptClient<quiz_attemptGetPayload<T>>> : CheckSelect<T, Prisma__quiz_attemptClient<quiz_attempt | null >, Prisma__quiz_attemptClient<quiz_attemptGetPayload<T> | null >>

    /**
     * Find zero or more Quiz_attempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_attemptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quiz_attempts
     * const quiz_attempts = await prisma.quiz_attempt.findMany()
     * 
     * // Get first 10 Quiz_attempts
     * const quiz_attempts = await prisma.quiz_attempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quiz_attemptWithIdOnly = await prisma.quiz_attempt.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends quiz_attemptFindManyArgs>(
      args?: SelectSubset<T, quiz_attemptFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<quiz_attempt>>, PrismaPromise<Array<quiz_attemptGetPayload<T>>>>

    /**
     * Create a Quiz_attempt.
     * @param {quiz_attemptCreateArgs} args - Arguments to create a Quiz_attempt.
     * @example
     * // Create one Quiz_attempt
     * const Quiz_attempt = await prisma.quiz_attempt.create({
     *   data: {
     *     // ... data to create a Quiz_attempt
     *   }
     * })
     * 
    **/
    create<T extends quiz_attemptCreateArgs>(
      args: SelectSubset<T, quiz_attemptCreateArgs>
    ): CheckSelect<T, Prisma__quiz_attemptClient<quiz_attempt>, Prisma__quiz_attemptClient<quiz_attemptGetPayload<T>>>

    /**
     * Create many Quiz_attempts.
     *     @param {quiz_attemptCreateManyArgs} args - Arguments to create many Quiz_attempts.
     *     @example
     *     // Create many Quiz_attempts
     *     const quiz_attempt = await prisma.quiz_attempt.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends quiz_attemptCreateManyArgs>(
      args?: SelectSubset<T, quiz_attemptCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Quiz_attempt.
     * @param {quiz_attemptDeleteArgs} args - Arguments to delete one Quiz_attempt.
     * @example
     * // Delete one Quiz_attempt
     * const Quiz_attempt = await prisma.quiz_attempt.delete({
     *   where: {
     *     // ... filter to delete one Quiz_attempt
     *   }
     * })
     * 
    **/
    delete<T extends quiz_attemptDeleteArgs>(
      args: SelectSubset<T, quiz_attemptDeleteArgs>
    ): CheckSelect<T, Prisma__quiz_attemptClient<quiz_attempt>, Prisma__quiz_attemptClient<quiz_attemptGetPayload<T>>>

    /**
     * Update one Quiz_attempt.
     * @param {quiz_attemptUpdateArgs} args - Arguments to update one Quiz_attempt.
     * @example
     * // Update one Quiz_attempt
     * const quiz_attempt = await prisma.quiz_attempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quiz_attemptUpdateArgs>(
      args: SelectSubset<T, quiz_attemptUpdateArgs>
    ): CheckSelect<T, Prisma__quiz_attemptClient<quiz_attempt>, Prisma__quiz_attemptClient<quiz_attemptGetPayload<T>>>

    /**
     * Delete zero or more Quiz_attempts.
     * @param {quiz_attemptDeleteManyArgs} args - Arguments to filter Quiz_attempts to delete.
     * @example
     * // Delete a few Quiz_attempts
     * const { count } = await prisma.quiz_attempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quiz_attemptDeleteManyArgs>(
      args?: SelectSubset<T, quiz_attemptDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quiz_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_attemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quiz_attempts
     * const quiz_attempt = await prisma.quiz_attempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quiz_attemptUpdateManyArgs>(
      args: SelectSubset<T, quiz_attemptUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Quiz_attempt.
     * @param {quiz_attemptUpsertArgs} args - Arguments to update or create a Quiz_attempt.
     * @example
     * // Update or create a Quiz_attempt
     * const quiz_attempt = await prisma.quiz_attempt.upsert({
     *   create: {
     *     // ... data to create a Quiz_attempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz_attempt we want to update
     *   }
     * })
    **/
    upsert<T extends quiz_attemptUpsertArgs>(
      args: SelectSubset<T, quiz_attemptUpsertArgs>
    ): CheckSelect<T, Prisma__quiz_attemptClient<quiz_attempt>, Prisma__quiz_attemptClient<quiz_attemptGetPayload<T>>>

    /**
     * Count the number of Quiz_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_attemptCountArgs} args - Arguments to filter Quiz_attempts to count.
     * @example
     * // Count the number of Quiz_attempts
     * const count = await prisma.quiz_attempt.count({
     *   where: {
     *     // ... the filter for the Quiz_attempts we want to count
     *   }
     * })
    **/
    count<T extends quiz_attemptCountArgs>(
      args?: Subset<T, quiz_attemptCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quiz_attemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz_attempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quiz_attemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quiz_attemptAggregateArgs>(args: Subset<T, Quiz_attemptAggregateArgs>): PrismaPromise<GetQuiz_attemptAggregateType<T>>

    /**
     * Group by Quiz_attempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quiz_attemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Quiz_attemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Quiz_attemptGroupByArgs['orderBy'] }
        : { orderBy?: Quiz_attemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Quiz_attemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuiz_attemptGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for quiz_attempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quiz_attemptClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    enrollment<T extends enrollmentArgs = {}>(args?: Subset<T, enrollmentArgs>): CheckSelect<T, Prisma__enrollmentClient<enrollment | null >, Prisma__enrollmentClient<enrollmentGetPayload<T> | null >>;

    quiz<T extends quizArgs = {}>(args?: Subset<T, quizArgs>): CheckSelect<T, Prisma__quizClient<quiz | null >, Prisma__quizClient<quizGetPayload<T> | null >>;

    student<T extends studentArgs = {}>(args?: Subset<T, studentArgs>): CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * quiz_attempt findUnique
   */
  export type quiz_attemptFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the quiz_attempt
     * 
    **/
    select?: quiz_attemptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_attemptInclude | null
    /**
     * Throw an Error if a quiz_attempt can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which quiz_attempt to fetch.
     * 
    **/
    where: quiz_attemptWhereUniqueInput
  }


  /**
   * quiz_attempt findFirst
   */
  export type quiz_attemptFindFirstArgs = {
    /**
     * Select specific fields to fetch from the quiz_attempt
     * 
    **/
    select?: quiz_attemptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_attemptInclude | null
    /**
     * Throw an Error if a quiz_attempt can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which quiz_attempt to fetch.
     * 
    **/
    where?: quiz_attemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_attempts to fetch.
     * 
    **/
    orderBy?: Enumerable<quiz_attemptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quiz_attempts.
     * 
    **/
    cursor?: quiz_attemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_attempts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_attempts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quiz_attempts.
     * 
    **/
    distinct?: Enumerable<Quiz_attemptScalarFieldEnum>
  }


  /**
   * quiz_attempt findMany
   */
  export type quiz_attemptFindManyArgs = {
    /**
     * Select specific fields to fetch from the quiz_attempt
     * 
    **/
    select?: quiz_attemptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_attemptInclude | null
    /**
     * Filter, which quiz_attempts to fetch.
     * 
    **/
    where?: quiz_attemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_attempts to fetch.
     * 
    **/
    orderBy?: Enumerable<quiz_attemptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quiz_attempts.
     * 
    **/
    cursor?: quiz_attemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_attempts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_attempts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Quiz_attemptScalarFieldEnum>
  }


  /**
   * quiz_attempt create
   */
  export type quiz_attemptCreateArgs = {
    /**
     * Select specific fields to fetch from the quiz_attempt
     * 
    **/
    select?: quiz_attemptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_attemptInclude | null
    /**
     * The data needed to create a quiz_attempt.
     * 
    **/
    data: XOR<quiz_attemptCreateInput, quiz_attemptUncheckedCreateInput>
  }


  /**
   * quiz_attempt createMany
   */
  export type quiz_attemptCreateManyArgs = {
    /**
     * The data used to create many quiz_attempts.
     * 
    **/
    data: Enumerable<quiz_attemptCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * quiz_attempt update
   */
  export type quiz_attemptUpdateArgs = {
    /**
     * Select specific fields to fetch from the quiz_attempt
     * 
    **/
    select?: quiz_attemptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_attemptInclude | null
    /**
     * The data needed to update a quiz_attempt.
     * 
    **/
    data: XOR<quiz_attemptUpdateInput, quiz_attemptUncheckedUpdateInput>
    /**
     * Choose, which quiz_attempt to update.
     * 
    **/
    where: quiz_attemptWhereUniqueInput
  }


  /**
   * quiz_attempt updateMany
   */
  export type quiz_attemptUpdateManyArgs = {
    /**
     * The data used to update quiz_attempts.
     * 
    **/
    data: XOR<quiz_attemptUpdateManyMutationInput, quiz_attemptUncheckedUpdateManyInput>
    /**
     * Filter which quiz_attempts to update
     * 
    **/
    where?: quiz_attemptWhereInput
  }


  /**
   * quiz_attempt upsert
   */
  export type quiz_attemptUpsertArgs = {
    /**
     * Select specific fields to fetch from the quiz_attempt
     * 
    **/
    select?: quiz_attemptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_attemptInclude | null
    /**
     * The filter to search for the quiz_attempt to update in case it exists.
     * 
    **/
    where: quiz_attemptWhereUniqueInput
    /**
     * In case the quiz_attempt found by the `where` argument doesn't exist, create a new quiz_attempt with this data.
     * 
    **/
    create: XOR<quiz_attemptCreateInput, quiz_attemptUncheckedCreateInput>
    /**
     * In case the quiz_attempt was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<quiz_attemptUpdateInput, quiz_attemptUncheckedUpdateInput>
  }


  /**
   * quiz_attempt delete
   */
  export type quiz_attemptDeleteArgs = {
    /**
     * Select specific fields to fetch from the quiz_attempt
     * 
    **/
    select?: quiz_attemptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_attemptInclude | null
    /**
     * Filter which quiz_attempt to delete.
     * 
    **/
    where: quiz_attemptWhereUniqueInput
  }


  /**
   * quiz_attempt deleteMany
   */
  export type quiz_attemptDeleteManyArgs = {
    /**
     * Filter which quiz_attempts to delete
     * 
    **/
    where?: quiz_attemptWhereInput
  }


  /**
   * quiz_attempt without action
   */
  export type quiz_attemptArgs = {
    /**
     * Select specific fields to fetch from the quiz_attempt
     * 
    **/
    select?: quiz_attemptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_attemptInclude | null
  }



  /**
   * Model quiz_question
   */


  export type AggregateQuiz_question = {
    _count: Quiz_questionCountAggregateOutputType | null
    _avg: Quiz_questionAvgAggregateOutputType | null
    _sum: Quiz_questionSumAggregateOutputType | null
    _min: Quiz_questionMinAggregateOutputType | null
    _max: Quiz_questionMaxAggregateOutputType | null
  }

  export type Quiz_questionAvgAggregateOutputType = {
    question_number: number | null
  }

  export type Quiz_questionSumAggregateOutputType = {
    question_number: number | null
  }

  export type Quiz_questionMinAggregateOutputType = {
    created_at: Date | null
    quiz_id: string | null
    question_id: string | null
    question_number: number | null
  }

  export type Quiz_questionMaxAggregateOutputType = {
    created_at: Date | null
    quiz_id: string | null
    question_id: string | null
    question_number: number | null
  }

  export type Quiz_questionCountAggregateOutputType = {
    created_at: number
    quiz_id: number
    question_id: number
    question_number: number
    _all: number
  }


  export type Quiz_questionAvgAggregateInputType = {
    question_number?: true
  }

  export type Quiz_questionSumAggregateInputType = {
    question_number?: true
  }

  export type Quiz_questionMinAggregateInputType = {
    created_at?: true
    quiz_id?: true
    question_id?: true
    question_number?: true
  }

  export type Quiz_questionMaxAggregateInputType = {
    created_at?: true
    quiz_id?: true
    question_id?: true
    question_number?: true
  }

  export type Quiz_questionCountAggregateInputType = {
    created_at?: true
    quiz_id?: true
    question_id?: true
    question_number?: true
    _all?: true
  }

  export type Quiz_questionAggregateArgs = {
    /**
     * Filter which quiz_question to aggregate.
     * 
    **/
    where?: quiz_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_questions to fetch.
     * 
    **/
    orderBy?: Enumerable<quiz_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: quiz_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quiz_questions
    **/
    _count?: true | Quiz_questionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Quiz_questionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Quiz_questionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quiz_questionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quiz_questionMaxAggregateInputType
  }

  export type GetQuiz_questionAggregateType<T extends Quiz_questionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz_question]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz_question[P]>
      : GetScalarType<T[P], AggregateQuiz_question[P]>
  }




  export type Quiz_questionGroupByArgs = {
    where?: quiz_questionWhereInput
    orderBy?: Enumerable<quiz_questionOrderByWithAggregationInput>
    by: Array<Quiz_questionScalarFieldEnum>
    having?: quiz_questionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quiz_questionCountAggregateInputType | true
    _avg?: Quiz_questionAvgAggregateInputType
    _sum?: Quiz_questionSumAggregateInputType
    _min?: Quiz_questionMinAggregateInputType
    _max?: Quiz_questionMaxAggregateInputType
  }


  export type Quiz_questionGroupByOutputType = {
    created_at: Date | null
    quiz_id: string
    question_id: string
    question_number: number | null
    _count: Quiz_questionCountAggregateOutputType | null
    _avg: Quiz_questionAvgAggregateOutputType | null
    _sum: Quiz_questionSumAggregateOutputType | null
    _min: Quiz_questionMinAggregateOutputType | null
    _max: Quiz_questionMaxAggregateOutputType | null
  }

  type GetQuiz_questionGroupByPayload<T extends Quiz_questionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Quiz_questionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quiz_questionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quiz_questionGroupByOutputType[P]>
            : GetScalarType<T[P], Quiz_questionGroupByOutputType[P]>
        }
      >
    >


  export type quiz_questionSelect = {
    created_at?: boolean
    quiz_id?: boolean
    question_id?: boolean
    question_number?: boolean
    quiz?: boolean | quizArgs
  }

  export type quiz_questionInclude = {
    quiz?: boolean | quizArgs
  }

  export type quiz_questionGetPayload<
    S extends boolean | null | undefined | quiz_questionArgs,
    U = keyof S
      > = S extends true
        ? quiz_question
    : S extends undefined
    ? never
    : S extends quiz_questionArgs | quiz_questionFindManyArgs
    ?'include' extends U
    ? quiz_question  & {
    [P in TrueKeys<S['include']>]:
        P extends 'quiz' ? quizGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'quiz' ? quizGetPayload<S['select'][P]> :  P extends keyof quiz_question ? quiz_question[P] : never
  } 
    : quiz_question
  : quiz_question


  type quiz_questionCountArgs = Merge<
    Omit<quiz_questionFindManyArgs, 'select' | 'include'> & {
      select?: Quiz_questionCountAggregateInputType | true
    }
  >

  export interface quiz_questionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Quiz_question that matches the filter.
     * @param {quiz_questionFindUniqueArgs} args - Arguments to find a Quiz_question
     * @example
     * // Get one Quiz_question
     * const quiz_question = await prisma.quiz_question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends quiz_questionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, quiz_questionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'quiz_question'> extends True ? CheckSelect<T, Prisma__quiz_questionClient<quiz_question>, Prisma__quiz_questionClient<quiz_questionGetPayload<T>>> : CheckSelect<T, Prisma__quiz_questionClient<quiz_question | null >, Prisma__quiz_questionClient<quiz_questionGetPayload<T> | null >>

    /**
     * Find the first Quiz_question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_questionFindFirstArgs} args - Arguments to find a Quiz_question
     * @example
     * // Get one Quiz_question
     * const quiz_question = await prisma.quiz_question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends quiz_questionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, quiz_questionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'quiz_question'> extends True ? CheckSelect<T, Prisma__quiz_questionClient<quiz_question>, Prisma__quiz_questionClient<quiz_questionGetPayload<T>>> : CheckSelect<T, Prisma__quiz_questionClient<quiz_question | null >, Prisma__quiz_questionClient<quiz_questionGetPayload<T> | null >>

    /**
     * Find zero or more Quiz_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_questionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quiz_questions
     * const quiz_questions = await prisma.quiz_question.findMany()
     * 
     * // Get first 10 Quiz_questions
     * const quiz_questions = await prisma.quiz_question.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const quiz_questionWithCreated_atOnly = await prisma.quiz_question.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends quiz_questionFindManyArgs>(
      args?: SelectSubset<T, quiz_questionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<quiz_question>>, PrismaPromise<Array<quiz_questionGetPayload<T>>>>

    /**
     * Create a Quiz_question.
     * @param {quiz_questionCreateArgs} args - Arguments to create a Quiz_question.
     * @example
     * // Create one Quiz_question
     * const Quiz_question = await prisma.quiz_question.create({
     *   data: {
     *     // ... data to create a Quiz_question
     *   }
     * })
     * 
    **/
    create<T extends quiz_questionCreateArgs>(
      args: SelectSubset<T, quiz_questionCreateArgs>
    ): CheckSelect<T, Prisma__quiz_questionClient<quiz_question>, Prisma__quiz_questionClient<quiz_questionGetPayload<T>>>

    /**
     * Create many Quiz_questions.
     *     @param {quiz_questionCreateManyArgs} args - Arguments to create many Quiz_questions.
     *     @example
     *     // Create many Quiz_questions
     *     const quiz_question = await prisma.quiz_question.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends quiz_questionCreateManyArgs>(
      args?: SelectSubset<T, quiz_questionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Quiz_question.
     * @param {quiz_questionDeleteArgs} args - Arguments to delete one Quiz_question.
     * @example
     * // Delete one Quiz_question
     * const Quiz_question = await prisma.quiz_question.delete({
     *   where: {
     *     // ... filter to delete one Quiz_question
     *   }
     * })
     * 
    **/
    delete<T extends quiz_questionDeleteArgs>(
      args: SelectSubset<T, quiz_questionDeleteArgs>
    ): CheckSelect<T, Prisma__quiz_questionClient<quiz_question>, Prisma__quiz_questionClient<quiz_questionGetPayload<T>>>

    /**
     * Update one Quiz_question.
     * @param {quiz_questionUpdateArgs} args - Arguments to update one Quiz_question.
     * @example
     * // Update one Quiz_question
     * const quiz_question = await prisma.quiz_question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quiz_questionUpdateArgs>(
      args: SelectSubset<T, quiz_questionUpdateArgs>
    ): CheckSelect<T, Prisma__quiz_questionClient<quiz_question>, Prisma__quiz_questionClient<quiz_questionGetPayload<T>>>

    /**
     * Delete zero or more Quiz_questions.
     * @param {quiz_questionDeleteManyArgs} args - Arguments to filter Quiz_questions to delete.
     * @example
     * // Delete a few Quiz_questions
     * const { count } = await prisma.quiz_question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quiz_questionDeleteManyArgs>(
      args?: SelectSubset<T, quiz_questionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quiz_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_questionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quiz_questions
     * const quiz_question = await prisma.quiz_question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quiz_questionUpdateManyArgs>(
      args: SelectSubset<T, quiz_questionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Quiz_question.
     * @param {quiz_questionUpsertArgs} args - Arguments to update or create a Quiz_question.
     * @example
     * // Update or create a Quiz_question
     * const quiz_question = await prisma.quiz_question.upsert({
     *   create: {
     *     // ... data to create a Quiz_question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz_question we want to update
     *   }
     * })
    **/
    upsert<T extends quiz_questionUpsertArgs>(
      args: SelectSubset<T, quiz_questionUpsertArgs>
    ): CheckSelect<T, Prisma__quiz_questionClient<quiz_question>, Prisma__quiz_questionClient<quiz_questionGetPayload<T>>>

    /**
     * Count the number of Quiz_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_questionCountArgs} args - Arguments to filter Quiz_questions to count.
     * @example
     * // Count the number of Quiz_questions
     * const count = await prisma.quiz_question.count({
     *   where: {
     *     // ... the filter for the Quiz_questions we want to count
     *   }
     * })
    **/
    count<T extends quiz_questionCountArgs>(
      args?: Subset<T, quiz_questionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quiz_questionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz_question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quiz_questionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quiz_questionAggregateArgs>(args: Subset<T, Quiz_questionAggregateArgs>): PrismaPromise<GetQuiz_questionAggregateType<T>>

    /**
     * Group by Quiz_question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quiz_questionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Quiz_questionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Quiz_questionGroupByArgs['orderBy'] }
        : { orderBy?: Quiz_questionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Quiz_questionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuiz_questionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for quiz_question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quiz_questionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    quiz<T extends quizArgs = {}>(args?: Subset<T, quizArgs>): CheckSelect<T, Prisma__quizClient<quiz | null >, Prisma__quizClient<quizGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * quiz_question findUnique
   */
  export type quiz_questionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the quiz_question
     * 
    **/
    select?: quiz_questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_questionInclude | null
    /**
     * Throw an Error if a quiz_question can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which quiz_question to fetch.
     * 
    **/
    where: quiz_questionWhereUniqueInput
  }


  /**
   * quiz_question findFirst
   */
  export type quiz_questionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the quiz_question
     * 
    **/
    select?: quiz_questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_questionInclude | null
    /**
     * Throw an Error if a quiz_question can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which quiz_question to fetch.
     * 
    **/
    where?: quiz_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_questions to fetch.
     * 
    **/
    orderBy?: Enumerable<quiz_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quiz_questions.
     * 
    **/
    cursor?: quiz_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quiz_questions.
     * 
    **/
    distinct?: Enumerable<Quiz_questionScalarFieldEnum>
  }


  /**
   * quiz_question findMany
   */
  export type quiz_questionFindManyArgs = {
    /**
     * Select specific fields to fetch from the quiz_question
     * 
    **/
    select?: quiz_questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_questionInclude | null
    /**
     * Filter, which quiz_questions to fetch.
     * 
    **/
    where?: quiz_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_questions to fetch.
     * 
    **/
    orderBy?: Enumerable<quiz_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quiz_questions.
     * 
    **/
    cursor?: quiz_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_questions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Quiz_questionScalarFieldEnum>
  }


  /**
   * quiz_question create
   */
  export type quiz_questionCreateArgs = {
    /**
     * Select specific fields to fetch from the quiz_question
     * 
    **/
    select?: quiz_questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_questionInclude | null
    /**
     * The data needed to create a quiz_question.
     * 
    **/
    data: XOR<quiz_questionCreateInput, quiz_questionUncheckedCreateInput>
  }


  /**
   * quiz_question createMany
   */
  export type quiz_questionCreateManyArgs = {
    /**
     * The data used to create many quiz_questions.
     * 
    **/
    data: Enumerable<quiz_questionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * quiz_question update
   */
  export type quiz_questionUpdateArgs = {
    /**
     * Select specific fields to fetch from the quiz_question
     * 
    **/
    select?: quiz_questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_questionInclude | null
    /**
     * The data needed to update a quiz_question.
     * 
    **/
    data: XOR<quiz_questionUpdateInput, quiz_questionUncheckedUpdateInput>
    /**
     * Choose, which quiz_question to update.
     * 
    **/
    where: quiz_questionWhereUniqueInput
  }


  /**
   * quiz_question updateMany
   */
  export type quiz_questionUpdateManyArgs = {
    /**
     * The data used to update quiz_questions.
     * 
    **/
    data: XOR<quiz_questionUpdateManyMutationInput, quiz_questionUncheckedUpdateManyInput>
    /**
     * Filter which quiz_questions to update
     * 
    **/
    where?: quiz_questionWhereInput
  }


  /**
   * quiz_question upsert
   */
  export type quiz_questionUpsertArgs = {
    /**
     * Select specific fields to fetch from the quiz_question
     * 
    **/
    select?: quiz_questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_questionInclude | null
    /**
     * The filter to search for the quiz_question to update in case it exists.
     * 
    **/
    where: quiz_questionWhereUniqueInput
    /**
     * In case the quiz_question found by the `where` argument doesn't exist, create a new quiz_question with this data.
     * 
    **/
    create: XOR<quiz_questionCreateInput, quiz_questionUncheckedCreateInput>
    /**
     * In case the quiz_question was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<quiz_questionUpdateInput, quiz_questionUncheckedUpdateInput>
  }


  /**
   * quiz_question delete
   */
  export type quiz_questionDeleteArgs = {
    /**
     * Select specific fields to fetch from the quiz_question
     * 
    **/
    select?: quiz_questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_questionInclude | null
    /**
     * Filter which quiz_question to delete.
     * 
    **/
    where: quiz_questionWhereUniqueInput
  }


  /**
   * quiz_question deleteMany
   */
  export type quiz_questionDeleteManyArgs = {
    /**
     * Filter which quiz_questions to delete
     * 
    **/
    where?: quiz_questionWhereInput
  }


  /**
   * quiz_question without action
   */
  export type quiz_questionArgs = {
    /**
     * Select specific fields to fetch from the quiz_question
     * 
    **/
    select?: quiz_questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quiz_questionInclude | null
  }



  /**
   * Model quiz
   */


  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    author: string | null
  }

  export type QuizMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    author: string | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    author: number
    _all: number
  }


  export type QuizMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    author?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    author?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    author?: true
    _all?: true
  }

  export type QuizAggregateArgs = {
    /**
     * Filter which quiz to aggregate.
     * 
    **/
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     * 
    **/
    orderBy?: Enumerable<quizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs = {
    where?: quizWhereInput
    orderBy?: Enumerable<quizOrderByWithAggregationInput>
    by: Array<QuizScalarFieldEnum>
    having?: quizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }


  export type QuizGroupByOutputType = {
    id: string
    created_at: Date | null
    updated_at: Date | null
    author: string | null
    _count: QuizCountAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type quizSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    author?: boolean
    attempts?: boolean | quiz_attemptFindManyArgs
    questions?: boolean | quiz_questionFindManyArgs
    _count?: boolean | QuizCountOutputTypeArgs
  }

  export type quizInclude = {
    attempts?: boolean | quiz_attemptFindManyArgs
    questions?: boolean | quiz_questionFindManyArgs
    _count?: boolean | QuizCountOutputTypeArgs
  }

  export type quizGetPayload<
    S extends boolean | null | undefined | quizArgs,
    U = keyof S
      > = S extends true
        ? quiz
    : S extends undefined
    ? never
    : S extends quizArgs | quizFindManyArgs
    ?'include' extends U
    ? quiz  & {
    [P in TrueKeys<S['include']>]:
        P extends 'attempts' ? Array < quiz_attemptGetPayload<S['include'][P]>>  :
        P extends 'questions' ? Array < quiz_questionGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'attempts' ? Array < quiz_attemptGetPayload<S['select'][P]>>  :
        P extends 'questions' ? Array < quiz_questionGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof quiz ? quiz[P] : never
  } 
    : quiz
  : quiz


  type quizCountArgs = Merge<
    Omit<quizFindManyArgs, 'select' | 'include'> & {
      select?: QuizCountAggregateInputType | true
    }
  >

  export interface quizDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {quizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends quizFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, quizFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'quiz'> extends True ? CheckSelect<T, Prisma__quizClient<quiz>, Prisma__quizClient<quizGetPayload<T>>> : CheckSelect<T, Prisma__quizClient<quiz | null >, Prisma__quizClient<quizGetPayload<T> | null >>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends quizFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, quizFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'quiz'> extends True ? CheckSelect<T, Prisma__quizClient<quiz>, Prisma__quizClient<quizGetPayload<T>>> : CheckSelect<T, Prisma__quizClient<quiz | null >, Prisma__quizClient<quizGetPayload<T> | null >>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends quizFindManyArgs>(
      args?: SelectSubset<T, quizFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<quiz>>, PrismaPromise<Array<quizGetPayload<T>>>>

    /**
     * Create a Quiz.
     * @param {quizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
    **/
    create<T extends quizCreateArgs>(
      args: SelectSubset<T, quizCreateArgs>
    ): CheckSelect<T, Prisma__quizClient<quiz>, Prisma__quizClient<quizGetPayload<T>>>

    /**
     * Create many Quizzes.
     *     @param {quizCreateManyArgs} args - Arguments to create many Quizzes.
     *     @example
     *     // Create many Quizzes
     *     const quiz = await prisma.quiz.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends quizCreateManyArgs>(
      args?: SelectSubset<T, quizCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Quiz.
     * @param {quizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
    **/
    delete<T extends quizDeleteArgs>(
      args: SelectSubset<T, quizDeleteArgs>
    ): CheckSelect<T, Prisma__quizClient<quiz>, Prisma__quizClient<quizGetPayload<T>>>

    /**
     * Update one Quiz.
     * @param {quizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quizUpdateArgs>(
      args: SelectSubset<T, quizUpdateArgs>
    ): CheckSelect<T, Prisma__quizClient<quiz>, Prisma__quizClient<quizGetPayload<T>>>

    /**
     * Delete zero or more Quizzes.
     * @param {quizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quizDeleteManyArgs>(
      args?: SelectSubset<T, quizDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quizUpdateManyArgs>(
      args: SelectSubset<T, quizUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Quiz.
     * @param {quizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
    **/
    upsert<T extends quizUpsertArgs>(
      args: SelectSubset<T, quizUpsertArgs>
    ): CheckSelect<T, Prisma__quizClient<quiz>, Prisma__quizClient<quizGetPayload<T>>>

    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends quizCountArgs>(
      args?: Subset<T, quizCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quizClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    attempts<T extends quiz_attemptFindManyArgs = {}>(args?: Subset<T, quiz_attemptFindManyArgs>): CheckSelect<T, PrismaPromise<Array<quiz_attempt>>, PrismaPromise<Array<quiz_attemptGetPayload<T>>>>;

    questions<T extends quiz_questionFindManyArgs = {}>(args?: Subset<T, quiz_questionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<quiz_question>>, PrismaPromise<Array<quiz_questionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * quiz findUnique
   */
  export type quizFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the quiz
     * 
    **/
    select?: quizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizInclude | null
    /**
     * Throw an Error if a quiz can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which quiz to fetch.
     * 
    **/
    where: quizWhereUniqueInput
  }


  /**
   * quiz findFirst
   */
  export type quizFindFirstArgs = {
    /**
     * Select specific fields to fetch from the quiz
     * 
    **/
    select?: quizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizInclude | null
    /**
     * Throw an Error if a quiz can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which quiz to fetch.
     * 
    **/
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     * 
    **/
    orderBy?: Enumerable<quizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizzes.
     * 
    **/
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizzes.
     * 
    **/
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * quiz findMany
   */
  export type quizFindManyArgs = {
    /**
     * Select specific fields to fetch from the quiz
     * 
    **/
    select?: quizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizInclude | null
    /**
     * Filter, which quizzes to fetch.
     * 
    **/
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     * 
    **/
    orderBy?: Enumerable<quizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quizzes.
     * 
    **/
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuizScalarFieldEnum>
  }


  /**
   * quiz create
   */
  export type quizCreateArgs = {
    /**
     * Select specific fields to fetch from the quiz
     * 
    **/
    select?: quizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizInclude | null
    /**
     * The data needed to create a quiz.
     * 
    **/
    data: XOR<quizCreateInput, quizUncheckedCreateInput>
  }


  /**
   * quiz createMany
   */
  export type quizCreateManyArgs = {
    /**
     * The data used to create many quizzes.
     * 
    **/
    data: Enumerable<quizCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * quiz update
   */
  export type quizUpdateArgs = {
    /**
     * Select specific fields to fetch from the quiz
     * 
    **/
    select?: quizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizInclude | null
    /**
     * The data needed to update a quiz.
     * 
    **/
    data: XOR<quizUpdateInput, quizUncheckedUpdateInput>
    /**
     * Choose, which quiz to update.
     * 
    **/
    where: quizWhereUniqueInput
  }


  /**
   * quiz updateMany
   */
  export type quizUpdateManyArgs = {
    /**
     * The data used to update quizzes.
     * 
    **/
    data: XOR<quizUpdateManyMutationInput, quizUncheckedUpdateManyInput>
    /**
     * Filter which quizzes to update
     * 
    **/
    where?: quizWhereInput
  }


  /**
   * quiz upsert
   */
  export type quizUpsertArgs = {
    /**
     * Select specific fields to fetch from the quiz
     * 
    **/
    select?: quizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizInclude | null
    /**
     * The filter to search for the quiz to update in case it exists.
     * 
    **/
    where: quizWhereUniqueInput
    /**
     * In case the quiz found by the `where` argument doesn't exist, create a new quiz with this data.
     * 
    **/
    create: XOR<quizCreateInput, quizUncheckedCreateInput>
    /**
     * In case the quiz was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<quizUpdateInput, quizUncheckedUpdateInput>
  }


  /**
   * quiz delete
   */
  export type quizDeleteArgs = {
    /**
     * Select specific fields to fetch from the quiz
     * 
    **/
    select?: quizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizInclude | null
    /**
     * Filter which quiz to delete.
     * 
    **/
    where: quizWhereUniqueInput
  }


  /**
   * quiz deleteMany
   */
  export type quizDeleteManyArgs = {
    /**
     * Filter which quizzes to delete
     * 
    **/
    where?: quizWhereInput
  }


  /**
   * quiz without action
   */
  export type quizArgs = {
    /**
     * Select specific fields to fetch from the quiz
     * 
    **/
    select?: quizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizInclude | null
  }



  /**
   * Model student_module
   */


  export type AggregateStudent_module = {
    _count: Student_moduleCountAggregateOutputType | null
    _min: Student_moduleMinAggregateOutputType | null
    _max: Student_moduleMaxAggregateOutputType | null
  }

  export type Student_moduleMinAggregateOutputType = {
    student_id: string | null
    module_id: string | null
    time_started: Date | null
  }

  export type Student_moduleMaxAggregateOutputType = {
    student_id: string | null
    module_id: string | null
    time_started: Date | null
  }

  export type Student_moduleCountAggregateOutputType = {
    student_id: number
    module_id: number
    time_started: number
    _all: number
  }


  export type Student_moduleMinAggregateInputType = {
    student_id?: true
    module_id?: true
    time_started?: true
  }

  export type Student_moduleMaxAggregateInputType = {
    student_id?: true
    module_id?: true
    time_started?: true
  }

  export type Student_moduleCountAggregateInputType = {
    student_id?: true
    module_id?: true
    time_started?: true
    _all?: true
  }

  export type Student_moduleAggregateArgs = {
    /**
     * Filter which student_module to aggregate.
     * 
    **/
    where?: student_moduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_modules to fetch.
     * 
    **/
    orderBy?: Enumerable<student_moduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: student_moduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_modules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_modules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_modules
    **/
    _count?: true | Student_moduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_moduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_moduleMaxAggregateInputType
  }

  export type GetStudent_moduleAggregateType<T extends Student_moduleAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_module]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_module[P]>
      : GetScalarType<T[P], AggregateStudent_module[P]>
  }




  export type Student_moduleGroupByArgs = {
    where?: student_moduleWhereInput
    orderBy?: Enumerable<student_moduleOrderByWithAggregationInput>
    by: Array<Student_moduleScalarFieldEnum>
    having?: student_moduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_moduleCountAggregateInputType | true
    _min?: Student_moduleMinAggregateInputType
    _max?: Student_moduleMaxAggregateInputType
  }


  export type Student_moduleGroupByOutputType = {
    student_id: string
    module_id: string
    time_started: Date
    _count: Student_moduleCountAggregateOutputType | null
    _min: Student_moduleMinAggregateOutputType | null
    _max: Student_moduleMaxAggregateOutputType | null
  }

  type GetStudent_moduleGroupByPayload<T extends Student_moduleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Student_moduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_moduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_moduleGroupByOutputType[P]>
            : GetScalarType<T[P], Student_moduleGroupByOutputType[P]>
        }
      >
    >


  export type student_moduleSelect = {
    student_id?: boolean
    module_id?: boolean
    time_started?: boolean
    module?: boolean | moduleArgs
    student?: boolean | studentArgs
  }

  export type student_moduleInclude = {
    module?: boolean | moduleArgs
    student?: boolean | studentArgs
  }

  export type student_moduleGetPayload<
    S extends boolean | null | undefined | student_moduleArgs,
    U = keyof S
      > = S extends true
        ? student_module
    : S extends undefined
    ? never
    : S extends student_moduleArgs | student_moduleFindManyArgs
    ?'include' extends U
    ? student_module  & {
    [P in TrueKeys<S['include']>]:
        P extends 'module' ? moduleGetPayload<S['include'][P]> :
        P extends 'student' ? studentGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'module' ? moduleGetPayload<S['select'][P]> :
        P extends 'student' ? studentGetPayload<S['select'][P]> :  P extends keyof student_module ? student_module[P] : never
  } 
    : student_module
  : student_module


  type student_moduleCountArgs = Merge<
    Omit<student_moduleFindManyArgs, 'select' | 'include'> & {
      select?: Student_moduleCountAggregateInputType | true
    }
  >

  export interface student_moduleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Student_module that matches the filter.
     * @param {student_moduleFindUniqueArgs} args - Arguments to find a Student_module
     * @example
     * // Get one Student_module
     * const student_module = await prisma.student_module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends student_moduleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, student_moduleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'student_module'> extends True ? CheckSelect<T, Prisma__student_moduleClient<student_module>, Prisma__student_moduleClient<student_moduleGetPayload<T>>> : CheckSelect<T, Prisma__student_moduleClient<student_module | null >, Prisma__student_moduleClient<student_moduleGetPayload<T> | null >>

    /**
     * Find the first Student_module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_moduleFindFirstArgs} args - Arguments to find a Student_module
     * @example
     * // Get one Student_module
     * const student_module = await prisma.student_module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends student_moduleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, student_moduleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'student_module'> extends True ? CheckSelect<T, Prisma__student_moduleClient<student_module>, Prisma__student_moduleClient<student_moduleGetPayload<T>>> : CheckSelect<T, Prisma__student_moduleClient<student_module | null >, Prisma__student_moduleClient<student_moduleGetPayload<T> | null >>

    /**
     * Find zero or more Student_modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_moduleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_modules
     * const student_modules = await prisma.student_module.findMany()
     * 
     * // Get first 10 Student_modules
     * const student_modules = await prisma.student_module.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const student_moduleWithStudent_idOnly = await prisma.student_module.findMany({ select: { student_id: true } })
     * 
    **/
    findMany<T extends student_moduleFindManyArgs>(
      args?: SelectSubset<T, student_moduleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<student_module>>, PrismaPromise<Array<student_moduleGetPayload<T>>>>

    /**
     * Create a Student_module.
     * @param {student_moduleCreateArgs} args - Arguments to create a Student_module.
     * @example
     * // Create one Student_module
     * const Student_module = await prisma.student_module.create({
     *   data: {
     *     // ... data to create a Student_module
     *   }
     * })
     * 
    **/
    create<T extends student_moduleCreateArgs>(
      args: SelectSubset<T, student_moduleCreateArgs>
    ): CheckSelect<T, Prisma__student_moduleClient<student_module>, Prisma__student_moduleClient<student_moduleGetPayload<T>>>

    /**
     * Create many Student_modules.
     *     @param {student_moduleCreateManyArgs} args - Arguments to create many Student_modules.
     *     @example
     *     // Create many Student_modules
     *     const student_module = await prisma.student_module.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends student_moduleCreateManyArgs>(
      args?: SelectSubset<T, student_moduleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Student_module.
     * @param {student_moduleDeleteArgs} args - Arguments to delete one Student_module.
     * @example
     * // Delete one Student_module
     * const Student_module = await prisma.student_module.delete({
     *   where: {
     *     // ... filter to delete one Student_module
     *   }
     * })
     * 
    **/
    delete<T extends student_moduleDeleteArgs>(
      args: SelectSubset<T, student_moduleDeleteArgs>
    ): CheckSelect<T, Prisma__student_moduleClient<student_module>, Prisma__student_moduleClient<student_moduleGetPayload<T>>>

    /**
     * Update one Student_module.
     * @param {student_moduleUpdateArgs} args - Arguments to update one Student_module.
     * @example
     * // Update one Student_module
     * const student_module = await prisma.student_module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends student_moduleUpdateArgs>(
      args: SelectSubset<T, student_moduleUpdateArgs>
    ): CheckSelect<T, Prisma__student_moduleClient<student_module>, Prisma__student_moduleClient<student_moduleGetPayload<T>>>

    /**
     * Delete zero or more Student_modules.
     * @param {student_moduleDeleteManyArgs} args - Arguments to filter Student_modules to delete.
     * @example
     * // Delete a few Student_modules
     * const { count } = await prisma.student_module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends student_moduleDeleteManyArgs>(
      args?: SelectSubset<T, student_moduleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_moduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_modules
     * const student_module = await prisma.student_module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends student_moduleUpdateManyArgs>(
      args: SelectSubset<T, student_moduleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_module.
     * @param {student_moduleUpsertArgs} args - Arguments to update or create a Student_module.
     * @example
     * // Update or create a Student_module
     * const student_module = await prisma.student_module.upsert({
     *   create: {
     *     // ... data to create a Student_module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_module we want to update
     *   }
     * })
    **/
    upsert<T extends student_moduleUpsertArgs>(
      args: SelectSubset<T, student_moduleUpsertArgs>
    ): CheckSelect<T, Prisma__student_moduleClient<student_module>, Prisma__student_moduleClient<student_moduleGetPayload<T>>>

    /**
     * Count the number of Student_modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_moduleCountArgs} args - Arguments to filter Student_modules to count.
     * @example
     * // Count the number of Student_modules
     * const count = await prisma.student_module.count({
     *   where: {
     *     // ... the filter for the Student_modules we want to count
     *   }
     * })
    **/
    count<T extends student_moduleCountArgs>(
      args?: Subset<T, student_moduleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_moduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_moduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_moduleAggregateArgs>(args: Subset<T, Student_moduleAggregateArgs>): PrismaPromise<GetStudent_moduleAggregateType<T>>

    /**
     * Group by Student_module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_moduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Student_moduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Student_moduleGroupByArgs['orderBy'] }
        : { orderBy?: Student_moduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Student_moduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_moduleGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__student_moduleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    module<T extends moduleArgs = {}>(args?: Subset<T, moduleArgs>): CheckSelect<T, Prisma__moduleClient<module | null >, Prisma__moduleClient<moduleGetPayload<T> | null >>;

    student<T extends studentArgs = {}>(args?: Subset<T, studentArgs>): CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * student_module findUnique
   */
  export type student_moduleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the student_module
     * 
    **/
    select?: student_moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: student_moduleInclude | null
    /**
     * Throw an Error if a student_module can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which student_module to fetch.
     * 
    **/
    where: student_moduleWhereUniqueInput
  }


  /**
   * student_module findFirst
   */
  export type student_moduleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the student_module
     * 
    **/
    select?: student_moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: student_moduleInclude | null
    /**
     * Throw an Error if a student_module can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which student_module to fetch.
     * 
    **/
    where?: student_moduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_modules to fetch.
     * 
    **/
    orderBy?: Enumerable<student_moduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_modules.
     * 
    **/
    cursor?: student_moduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_modules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_modules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_modules.
     * 
    **/
    distinct?: Enumerable<Student_moduleScalarFieldEnum>
  }


  /**
   * student_module findMany
   */
  export type student_moduleFindManyArgs = {
    /**
     * Select specific fields to fetch from the student_module
     * 
    **/
    select?: student_moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: student_moduleInclude | null
    /**
     * Filter, which student_modules to fetch.
     * 
    **/
    where?: student_moduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_modules to fetch.
     * 
    **/
    orderBy?: Enumerable<student_moduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_modules.
     * 
    **/
    cursor?: student_moduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_modules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_modules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Student_moduleScalarFieldEnum>
  }


  /**
   * student_module create
   */
  export type student_moduleCreateArgs = {
    /**
     * Select specific fields to fetch from the student_module
     * 
    **/
    select?: student_moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: student_moduleInclude | null
    /**
     * The data needed to create a student_module.
     * 
    **/
    data: XOR<student_moduleCreateInput, student_moduleUncheckedCreateInput>
  }


  /**
   * student_module createMany
   */
  export type student_moduleCreateManyArgs = {
    /**
     * The data used to create many student_modules.
     * 
    **/
    data: Enumerable<student_moduleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * student_module update
   */
  export type student_moduleUpdateArgs = {
    /**
     * Select specific fields to fetch from the student_module
     * 
    **/
    select?: student_moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: student_moduleInclude | null
    /**
     * The data needed to update a student_module.
     * 
    **/
    data: XOR<student_moduleUpdateInput, student_moduleUncheckedUpdateInput>
    /**
     * Choose, which student_module to update.
     * 
    **/
    where: student_moduleWhereUniqueInput
  }


  /**
   * student_module updateMany
   */
  export type student_moduleUpdateManyArgs = {
    /**
     * The data used to update student_modules.
     * 
    **/
    data: XOR<student_moduleUpdateManyMutationInput, student_moduleUncheckedUpdateManyInput>
    /**
     * Filter which student_modules to update
     * 
    **/
    where?: student_moduleWhereInput
  }


  /**
   * student_module upsert
   */
  export type student_moduleUpsertArgs = {
    /**
     * Select specific fields to fetch from the student_module
     * 
    **/
    select?: student_moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: student_moduleInclude | null
    /**
     * The filter to search for the student_module to update in case it exists.
     * 
    **/
    where: student_moduleWhereUniqueInput
    /**
     * In case the student_module found by the `where` argument doesn't exist, create a new student_module with this data.
     * 
    **/
    create: XOR<student_moduleCreateInput, student_moduleUncheckedCreateInput>
    /**
     * In case the student_module was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<student_moduleUpdateInput, student_moduleUncheckedUpdateInput>
  }


  /**
   * student_module delete
   */
  export type student_moduleDeleteArgs = {
    /**
     * Select specific fields to fetch from the student_module
     * 
    **/
    select?: student_moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: student_moduleInclude | null
    /**
     * Filter which student_module to delete.
     * 
    **/
    where: student_moduleWhereUniqueInput
  }


  /**
   * student_module deleteMany
   */
  export type student_moduleDeleteManyArgs = {
    /**
     * Filter which student_modules to delete
     * 
    **/
    where?: student_moduleWhereInput
  }


  /**
   * student_module without action
   */
  export type student_moduleArgs = {
    /**
     * Select specific fields to fetch from the student_module
     * 
    **/
    select?: student_moduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: student_moduleInclude | null
  }



  /**
   * Model student
   */


  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    grade_at_account_creation: number | null
  }

  export type StudentSumAggregateOutputType = {
    grade_at_account_creation: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    grade_at_account_creation: number | null
    user_id: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    grade_at_account_creation: number | null
    user_id: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    created_at: number
    grade_at_account_creation: number
    user_id: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    grade_at_account_creation?: true
  }

  export type StudentSumAggregateInputType = {
    grade_at_account_creation?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    created_at?: true
    grade_at_account_creation?: true
    user_id?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    created_at?: true
    grade_at_account_creation?: true
    user_id?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    created_at?: true
    grade_at_account_creation?: true
    user_id?: true
    _all?: true
  }

  export type StudentAggregateArgs = {
    /**
     * Filter which student to aggregate.
     * 
    **/
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     * 
    **/
    orderBy?: Enumerable<studentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs = {
    where?: studentWhereInput
    orderBy?: Enumerable<studentOrderByWithAggregationInput>
    by: Array<StudentScalarFieldEnum>
    having?: studentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }


  export type StudentGroupByOutputType = {
    id: string
    created_at: Date | null
    grade_at_account_creation: number | null
    user_id: string | null
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type studentSelect = {
    id?: boolean
    created_at?: boolean
    grade_at_account_creation?: boolean
    user_id?: boolean
    User?: boolean | UserArgs
    enrollment?: boolean | enrollmentFindManyArgs
    quiz_attempt?: boolean | quiz_attemptFindManyArgs
    student_module?: boolean | student_moduleFindManyArgs
    _count?: boolean | StudentCountOutputTypeArgs
  }

  export type studentInclude = {
    User?: boolean | UserArgs
    enrollment?: boolean | enrollmentFindManyArgs
    quiz_attempt?: boolean | quiz_attemptFindManyArgs
    student_module?: boolean | student_moduleFindManyArgs
    _count?: boolean | StudentCountOutputTypeArgs
  }

  export type studentGetPayload<
    S extends boolean | null | undefined | studentArgs,
    U = keyof S
      > = S extends true
        ? student
    : S extends undefined
    ? never
    : S extends studentArgs | studentFindManyArgs
    ?'include' extends U
    ? student  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :
        P extends 'enrollment' ? Array < enrollmentGetPayload<S['include'][P]>>  :
        P extends 'quiz_attempt' ? Array < quiz_attemptGetPayload<S['include'][P]>>  :
        P extends 'student_module' ? Array < student_moduleGetPayload<S['include'][P]>>  :
        P extends '_count' ? StudentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :
        P extends 'enrollment' ? Array < enrollmentGetPayload<S['select'][P]>>  :
        P extends 'quiz_attempt' ? Array < quiz_attemptGetPayload<S['select'][P]>>  :
        P extends 'student_module' ? Array < student_moduleGetPayload<S['select'][P]>>  :
        P extends '_count' ? StudentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof student ? student[P] : never
  } 
    : student
  : student


  type studentCountArgs = Merge<
    Omit<studentFindManyArgs, 'select' | 'include'> & {
      select?: StudentCountAggregateInputType | true
    }
  >

  export interface studentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Student that matches the filter.
     * @param {studentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends studentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, studentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'student'> extends True ? CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>> : CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends studentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, studentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'student'> extends True ? CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>> : CheckSelect<T, Prisma__studentClient<student | null >, Prisma__studentClient<studentGetPayload<T> | null >>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends studentFindManyArgs>(
      args?: SelectSubset<T, studentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<student>>, PrismaPromise<Array<studentGetPayload<T>>>>

    /**
     * Create a Student.
     * @param {studentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends studentCreateArgs>(
      args: SelectSubset<T, studentCreateArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Create many Students.
     *     @param {studentCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const student = await prisma.student.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends studentCreateManyArgs>(
      args?: SelectSubset<T, studentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {studentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends studentDeleteArgs>(
      args: SelectSubset<T, studentDeleteArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Update one Student.
     * @param {studentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends studentUpdateArgs>(
      args: SelectSubset<T, studentUpdateArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Delete zero or more Students.
     * @param {studentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends studentDeleteManyArgs>(
      args?: SelectSubset<T, studentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends studentUpdateManyArgs>(
      args: SelectSubset<T, studentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {studentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends studentUpsertArgs>(
      args: SelectSubset<T, studentUpsertArgs>
    ): CheckSelect<T, Prisma__studentClient<student>, Prisma__studentClient<studentGetPayload<T>>>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentCountArgs>(
      args?: Subset<T, studentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__studentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    enrollment<T extends enrollmentFindManyArgs = {}>(args?: Subset<T, enrollmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<enrollment>>, PrismaPromise<Array<enrollmentGetPayload<T>>>>;

    quiz_attempt<T extends quiz_attemptFindManyArgs = {}>(args?: Subset<T, quiz_attemptFindManyArgs>): CheckSelect<T, PrismaPromise<Array<quiz_attempt>>, PrismaPromise<Array<quiz_attemptGetPayload<T>>>>;

    student_module<T extends student_moduleFindManyArgs = {}>(args?: Subset<T, student_moduleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<student_module>>, PrismaPromise<Array<student_moduleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * student findUnique
   */
  export type studentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * Throw an Error if a student can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which student to fetch.
     * 
    **/
    where: studentWhereUniqueInput
  }


  /**
   * student findFirst
   */
  export type studentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * Throw an Error if a student can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which student to fetch.
     * 
    **/
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     * 
    **/
    orderBy?: Enumerable<studentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     * 
    **/
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     * 
    **/
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * student findMany
   */
  export type studentFindManyArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * Filter, which students to fetch.
     * 
    **/
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     * 
    **/
    orderBy?: Enumerable<studentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     * 
    **/
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * student create
   */
  export type studentCreateArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * The data needed to create a student.
     * 
    **/
    data: XOR<studentCreateInput, studentUncheckedCreateInput>
  }


  /**
   * student createMany
   */
  export type studentCreateManyArgs = {
    /**
     * The data used to create many students.
     * 
    **/
    data: Enumerable<studentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * student update
   */
  export type studentUpdateArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * The data needed to update a student.
     * 
    **/
    data: XOR<studentUpdateInput, studentUncheckedUpdateInput>
    /**
     * Choose, which student to update.
     * 
    **/
    where: studentWhereUniqueInput
  }


  /**
   * student updateMany
   */
  export type studentUpdateManyArgs = {
    /**
     * The data used to update students.
     * 
    **/
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     * 
    **/
    where?: studentWhereInput
  }


  /**
   * student upsert
   */
  export type studentUpsertArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * The filter to search for the student to update in case it exists.
     * 
    **/
    where: studentWhereUniqueInput
    /**
     * In case the student found by the `where` argument doesn't exist, create a new student with this data.
     * 
    **/
    create: XOR<studentCreateInput, studentUncheckedCreateInput>
    /**
     * In case the student was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<studentUpdateInput, studentUncheckedUpdateInput>
  }


  /**
   * student delete
   */
  export type studentDeleteArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
    /**
     * Filter which student to delete.
     * 
    **/
    where: studentWhereUniqueInput
  }


  /**
   * student deleteMany
   */
  export type studentDeleteManyArgs = {
    /**
     * Filter which students to delete
     * 
    **/
    where?: studentWhereInput
  }


  /**
   * student without action
   */
  export type studentArgs = {
    /**
     * Select specific fields to fetch from the student
     * 
    **/
    select?: studentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: studentInclude | null
  }



  /**
   * Model subject
   */


  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    created_at: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    id?: true
    created_at?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    created_at?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    created_at?: true
    _all?: true
  }

  export type SubjectAggregateArgs = {
    /**
     * Filter which subject to aggregate.
     * 
    **/
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs = {
    where?: subjectWhereInput
    orderBy?: Enumerable<subjectOrderByWithAggregationInput>
    by: Array<SubjectScalarFieldEnum>
    having?: subjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }


  export type SubjectGroupByOutputType = {
    id: string
    created_at: Date | null
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type subjectSelect = {
    id?: boolean
    created_at?: boolean
    module?: boolean | moduleFindManyArgs
    _count?: boolean | SubjectCountOutputTypeArgs
  }

  export type subjectInclude = {
    module?: boolean | moduleFindManyArgs
    _count?: boolean | SubjectCountOutputTypeArgs
  }

  export type subjectGetPayload<
    S extends boolean | null | undefined | subjectArgs,
    U = keyof S
      > = S extends true
        ? subject
    : S extends undefined
    ? never
    : S extends subjectArgs | subjectFindManyArgs
    ?'include' extends U
    ? subject  & {
    [P in TrueKeys<S['include']>]:
        P extends 'module' ? Array < moduleGetPayload<S['include'][P]>>  :
        P extends '_count' ? SubjectCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'module' ? Array < moduleGetPayload<S['select'][P]>>  :
        P extends '_count' ? SubjectCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof subject ? subject[P] : never
  } 
    : subject
  : subject


  type subjectCountArgs = Merge<
    Omit<subjectFindManyArgs, 'select' | 'include'> & {
      select?: SubjectCountAggregateInputType | true
    }
  >

  export interface subjectDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Subject that matches the filter.
     * @param {subjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subject'> extends True ? CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>> : CheckSelect<T, Prisma__subjectClient<subject | null >, Prisma__subjectClient<subjectGetPayload<T> | null >>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subject'> extends True ? CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>> : CheckSelect<T, Prisma__subjectClient<subject | null >, Prisma__subjectClient<subjectGetPayload<T> | null >>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subjectFindManyArgs>(
      args?: SelectSubset<T, subjectFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<subject>>, PrismaPromise<Array<subjectGetPayload<T>>>>

    /**
     * Create a Subject.
     * @param {subjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
    **/
    create<T extends subjectCreateArgs>(
      args: SelectSubset<T, subjectCreateArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Create many Subjects.
     *     @param {subjectCreateManyArgs} args - Arguments to create many Subjects.
     *     @example
     *     // Create many Subjects
     *     const subject = await prisma.subject.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subjectCreateManyArgs>(
      args?: SelectSubset<T, subjectCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subject.
     * @param {subjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
    **/
    delete<T extends subjectDeleteArgs>(
      args: SelectSubset<T, subjectDeleteArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Update one Subject.
     * @param {subjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subjectUpdateArgs>(
      args: SelectSubset<T, subjectUpdateArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Delete zero or more Subjects.
     * @param {subjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subjectDeleteManyArgs>(
      args?: SelectSubset<T, subjectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subjectUpdateManyArgs>(
      args: SelectSubset<T, subjectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {subjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
    **/
    upsert<T extends subjectUpsertArgs>(
      args: SelectSubset<T, subjectUpsertArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends subjectCountArgs>(
      args?: Subset<T, subjectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subjectClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    module<T extends moduleFindManyArgs = {}>(args?: Subset<T, moduleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<module>>, PrismaPromise<Array<moduleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * subject findUnique
   */
  export type subjectFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * Throw an Error if a subject can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which subject to fetch.
     * 
    **/
    where: subjectWhereUniqueInput
  }


  /**
   * subject findFirst
   */
  export type subjectFindFirstArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * Throw an Error if a subject can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which subject to fetch.
     * 
    **/
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     * 
    **/
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     * 
    **/
    distinct?: Enumerable<SubjectScalarFieldEnum>
  }


  /**
   * subject findMany
   */
  export type subjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * Filter, which subjects to fetch.
     * 
    **/
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjects.
     * 
    **/
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubjectScalarFieldEnum>
  }


  /**
   * subject create
   */
  export type subjectCreateArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * The data needed to create a subject.
     * 
    **/
    data: XOR<subjectCreateInput, subjectUncheckedCreateInput>
  }


  /**
   * subject createMany
   */
  export type subjectCreateManyArgs = {
    /**
     * The data used to create many subjects.
     * 
    **/
    data: Enumerable<subjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subject update
   */
  export type subjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * The data needed to update a subject.
     * 
    **/
    data: XOR<subjectUpdateInput, subjectUncheckedUpdateInput>
    /**
     * Choose, which subject to update.
     * 
    **/
    where: subjectWhereUniqueInput
  }


  /**
   * subject updateMany
   */
  export type subjectUpdateManyArgs = {
    /**
     * The data used to update subjects.
     * 
    **/
    data: XOR<subjectUpdateManyMutationInput, subjectUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     * 
    **/
    where?: subjectWhereInput
  }


  /**
   * subject upsert
   */
  export type subjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * The filter to search for the subject to update in case it exists.
     * 
    **/
    where: subjectWhereUniqueInput
    /**
     * In case the subject found by the `where` argument doesn't exist, create a new subject with this data.
     * 
    **/
    create: XOR<subjectCreateInput, subjectUncheckedCreateInput>
    /**
     * In case the subject was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subjectUpdateInput, subjectUncheckedUpdateInput>
  }


  /**
   * subject delete
   */
  export type subjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * Filter which subject to delete.
     * 
    **/
    where: subjectWhereUniqueInput
  }


  /**
   * subject deleteMany
   */
  export type subjectDeleteManyArgs = {
    /**
     * Filter which subjects to delete
     * 
    **/
    where?: subjectWhereInput
  }


  /**
   * subject without action
   */
  export type subjectArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    oauth_token_secret: 'oauth_token_secret',
    oauth_token: 'oauth_token'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    role: 'role',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    instructor_id: 'instructor_id',
    course_title: 'course_title',
    updated_at: 'updated_at',
    author: 'author'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    student_id: 'student_id',
    course_id: 'course_id',
    current_grade_level: 'current_grade_level'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const InstructorScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    user_id: 'user_id'
  };

  export type InstructorScalarFieldEnum = (typeof InstructorScalarFieldEnum)[keyof typeof InstructorScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    author: 'author',
    lesson_module: 'lesson_module'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    author: 'author',
    module_subject_id: 'module_subject_id',
    module_name: 'module_name'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const Question_topicScalarFieldEnum: {
    id: 'id',
    topic_id: 'topic_id',
    question_id: 'question_id'
  };

  export type Question_topicScalarFieldEnum = (typeof Question_topicScalarFieldEnum)[keyof typeof Question_topicScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    question_topic_name: 'question_topic_name'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    difficulty: 'difficulty',
    image_url: 'image_url',
    equation: 'equation',
    question_text: 'question_text',
    answer_formula: 'answer_formula',
    updated_at: 'updated_at',
    author: 'author'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const Quiz_attemptScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    student_id: 'student_id',
    quiz_id: 'quiz_id',
    total_points: 'total_points',
    points_scored: 'points_scored',
    enroll_id: 'enroll_id',
    answer_data: 'answer_data',
    question_answered_count: 'question_answered_count',
    question_unanswered_count: 'question_unanswered_count'
  };

  export type Quiz_attemptScalarFieldEnum = (typeof Quiz_attemptScalarFieldEnum)[keyof typeof Quiz_attemptScalarFieldEnum]


  export const Quiz_questionScalarFieldEnum: {
    created_at: 'created_at',
    quiz_id: 'quiz_id',
    question_id: 'question_id',
    question_number: 'question_number'
  };

  export type Quiz_questionScalarFieldEnum = (typeof Quiz_questionScalarFieldEnum)[keyof typeof Quiz_questionScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    author: 'author'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const Student_moduleScalarFieldEnum: {
    student_id: 'student_id',
    module_id: 'module_id',
    time_started: 'time_started'
  };

  export type Student_moduleScalarFieldEnum = (typeof Student_moduleScalarFieldEnum)[keyof typeof Student_moduleScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    grade_at_account_creation: 'grade_at_account_creation',
    user_id: 'user_id'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull'
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull',
    AnyNull: 'AnyNull'
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    oauth_token_secret?: StringNullableFilter | string | null
    oauth_token?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = {
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    providerAccountId?: StringWithAggregatesFilter | string
    refresh_token?: StringNullableWithAggregatesFilter | string | null
    access_token?: StringNullableWithAggregatesFilter | string | null
    expires_at?: IntNullableWithAggregatesFilter | number | null
    token_type?: StringNullableWithAggregatesFilter | string | null
    scope?: StringNullableWithAggregatesFilter | string | null
    id_token?: StringNullableWithAggregatesFilter | string | null
    session_state?: StringNullableWithAggregatesFilter | string | null
    oauth_token_secret?: StringNullableWithAggregatesFilter | string | null
    oauth_token?: StringNullableWithAggregatesFilter | string | null
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = {
    id?: string
    sessionToken?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sessionToken?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    role?: EnumRoleFilter | Role
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    image?: StringNullableFilter | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    instructor?: InstructorListRelationFilter
    student?: StudentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    instructor?: instructorOrderByRelationAggregateInput
    student?: studentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    role?: EnumRoleWithAggregatesFilter | Role
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    image?: StringNullableWithAggregatesFilter | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: Enumerable<VerificationTokenWhereInput>
    OR?: Enumerable<VerificationTokenWhereInput>
    NOT?: Enumerable<VerificationTokenWhereInput>
    identifier?: StringFilter | string
    token?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = {
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
  }

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    identifier?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type courseWhereInput = {
    AND?: Enumerable<courseWhereInput>
    OR?: Enumerable<courseWhereInput>
    NOT?: Enumerable<courseWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    instructor_id?: StringNullableFilter | string | null
    course_title?: StringFilter | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    author?: StringNullableFilter | string | null
    enrollment?: EnrollmentListRelationFilter
  }

  export type courseOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    instructor_id?: SortOrder
    course_title?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    enrollment?: enrollmentOrderByRelationAggregateInput
  }

  export type courseWhereUniqueInput = {
    id?: string
  }

  export type courseOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    instructor_id?: SortOrder
    course_title?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    _count?: courseCountOrderByAggregateInput
    _max?: courseMaxOrderByAggregateInput
    _min?: courseMinOrderByAggregateInput
  }

  export type courseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<courseScalarWhereWithAggregatesInput>
    OR?: Enumerable<courseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<courseScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    instructor_id?: StringNullableWithAggregatesFilter | string | null
    course_title?: StringWithAggregatesFilter | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    author?: StringNullableWithAggregatesFilter | string | null
  }

  export type enrollmentWhereInput = {
    AND?: Enumerable<enrollmentWhereInput>
    OR?: Enumerable<enrollmentWhereInput>
    NOT?: Enumerable<enrollmentWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    student_id?: StringNullableFilter | string | null
    course_id?: StringNullableFilter | string | null
    current_grade_level?: StringNullableFilter | string | null
    course?: XOR<CourseRelationFilter, courseWhereInput> | null
    student?: XOR<StudentRelationFilter, studentWhereInput> | null
    quiz_attempt?: Quiz_attemptListRelationFilter
  }

  export type enrollmentOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    course_id?: SortOrder
    current_grade_level?: SortOrder
    course?: courseOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
    quiz_attempt?: quiz_attemptOrderByRelationAggregateInput
  }

  export type enrollmentWhereUniqueInput = {
    id?: string
  }

  export type enrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    course_id?: SortOrder
    current_grade_level?: SortOrder
    _count?: enrollmentCountOrderByAggregateInput
    _max?: enrollmentMaxOrderByAggregateInput
    _min?: enrollmentMinOrderByAggregateInput
  }

  export type enrollmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<enrollmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<enrollmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<enrollmentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    student_id?: StringNullableWithAggregatesFilter | string | null
    course_id?: StringNullableWithAggregatesFilter | string | null
    current_grade_level?: StringNullableWithAggregatesFilter | string | null
  }

  export type instructorWhereInput = {
    AND?: Enumerable<instructorWhereInput>
    OR?: Enumerable<instructorWhereInput>
    NOT?: Enumerable<instructorWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: StringNullableFilter | string | null
    User?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type instructorOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type instructorWhereUniqueInput = {
    id?: string
  }

  export type instructorOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    _count?: instructorCountOrderByAggregateInput
    _max?: instructorMaxOrderByAggregateInput
    _min?: instructorMinOrderByAggregateInput
  }

  export type instructorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<instructorScalarWhereWithAggregatesInput>
    OR?: Enumerable<instructorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<instructorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type lessonWhereInput = {
    AND?: Enumerable<lessonWhereInput>
    OR?: Enumerable<lessonWhereInput>
    NOT?: Enumerable<lessonWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    author?: StringNullableFilter | string | null
    lesson_module?: StringNullableFilter | string | null
    module?: XOR<ModuleRelationFilter, moduleWhereInput> | null
  }

  export type lessonOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    lesson_module?: SortOrder
    module?: moduleOrderByWithRelationInput
  }

  export type lessonWhereUniqueInput = {
    id?: string
  }

  export type lessonOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    lesson_module?: SortOrder
    _count?: lessonCountOrderByAggregateInput
    _max?: lessonMaxOrderByAggregateInput
    _min?: lessonMinOrderByAggregateInput
  }

  export type lessonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<lessonScalarWhereWithAggregatesInput>
    OR?: Enumerable<lessonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<lessonScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    author?: StringNullableWithAggregatesFilter | string | null
    lesson_module?: StringNullableWithAggregatesFilter | string | null
  }

  export type moduleWhereInput = {
    AND?: Enumerable<moduleWhereInput>
    OR?: Enumerable<moduleWhereInput>
    NOT?: Enumerable<moduleWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    author?: StringNullableFilter | string | null
    module_subject_id?: StringNullableFilter | string | null
    module_name?: StringFilter | string
    subject?: XOR<SubjectRelationFilter, subjectWhereInput> | null
    lesson?: LessonListRelationFilter
    student_module?: Student_moduleListRelationFilter
  }

  export type moduleOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    module_subject_id?: SortOrder
    module_name?: SortOrder
    subject?: subjectOrderByWithRelationInput
    lesson?: lessonOrderByRelationAggregateInput
    student_module?: student_moduleOrderByRelationAggregateInput
  }

  export type moduleWhereUniqueInput = {
    id?: string
    module_name?: string
  }

  export type moduleOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    module_subject_id?: SortOrder
    module_name?: SortOrder
    _count?: moduleCountOrderByAggregateInput
    _max?: moduleMaxOrderByAggregateInput
    _min?: moduleMinOrderByAggregateInput
  }

  export type moduleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<moduleScalarWhereWithAggregatesInput>
    OR?: Enumerable<moduleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<moduleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    author?: StringNullableWithAggregatesFilter | string | null
    module_subject_id?: StringNullableWithAggregatesFilter | string | null
    module_name?: StringWithAggregatesFilter | string
  }

  export type question_topicWhereInput = {
    AND?: Enumerable<question_topicWhereInput>
    OR?: Enumerable<question_topicWhereInput>
    NOT?: Enumerable<question_topicWhereInput>
    id?: StringFilter | string
    topic_id?: StringFilter | string
    question_id?: StringNullableFilter | string | null
    question?: XOR<QuestionRelationFilter, questionWhereInput> | null
    topic?: XOR<TopicRelationFilter, topicWhereInput>
  }

  export type question_topicOrderByWithRelationInput = {
    id?: SortOrder
    topic_id?: SortOrder
    question_id?: SortOrder
    question?: questionOrderByWithRelationInput
    topic?: topicOrderByWithRelationInput
  }

  export type question_topicWhereUniqueInput = {
    id?: string
  }

  export type question_topicOrderByWithAggregationInput = {
    id?: SortOrder
    topic_id?: SortOrder
    question_id?: SortOrder
    _count?: question_topicCountOrderByAggregateInput
    _max?: question_topicMaxOrderByAggregateInput
    _min?: question_topicMinOrderByAggregateInput
  }

  export type question_topicScalarWhereWithAggregatesInput = {
    AND?: Enumerable<question_topicScalarWhereWithAggregatesInput>
    OR?: Enumerable<question_topicScalarWhereWithAggregatesInput>
    NOT?: Enumerable<question_topicScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    topic_id?: StringWithAggregatesFilter | string
    question_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type topicWhereInput = {
    AND?: Enumerable<topicWhereInput>
    OR?: Enumerable<topicWhereInput>
    NOT?: Enumerable<topicWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    question_topic_name?: StringFilter | string
    question_topic?: Question_topicListRelationFilter
  }

  export type topicOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    question_topic_name?: SortOrder
    question_topic?: question_topicOrderByRelationAggregateInput
  }

  export type topicWhereUniqueInput = {
    id?: string
  }

  export type topicOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    question_topic_name?: SortOrder
    _count?: topicCountOrderByAggregateInput
    _max?: topicMaxOrderByAggregateInput
    _min?: topicMinOrderByAggregateInput
  }

  export type topicScalarWhereWithAggregatesInput = {
    AND?: Enumerable<topicScalarWhereWithAggregatesInput>
    OR?: Enumerable<topicScalarWhereWithAggregatesInput>
    NOT?: Enumerable<topicScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    question_topic_name?: StringWithAggregatesFilter | string
  }

  export type questionWhereInput = {
    AND?: Enumerable<questionWhereInput>
    OR?: Enumerable<questionWhereInput>
    NOT?: Enumerable<questionWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    difficulty?: IntNullableFilter | number | null
    image_url?: StringNullableFilter | string | null
    equation?: StringNullableFilter | string | null
    question_text?: StringNullableFilter | string | null
    answer_formula?: StringNullableFilter | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    author?: StringNullableFilter | string | null
    question_topic?: Question_topicListRelationFilter
  }

  export type questionOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    difficulty?: SortOrder
    image_url?: SortOrder
    equation?: SortOrder
    question_text?: SortOrder
    answer_formula?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    question_topic?: question_topicOrderByRelationAggregateInput
  }

  export type questionWhereUniqueInput = {
    id?: string
  }

  export type questionOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    difficulty?: SortOrder
    image_url?: SortOrder
    equation?: SortOrder
    question_text?: SortOrder
    answer_formula?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    _count?: questionCountOrderByAggregateInput
    _avg?: questionAvgOrderByAggregateInput
    _max?: questionMaxOrderByAggregateInput
    _min?: questionMinOrderByAggregateInput
    _sum?: questionSumOrderByAggregateInput
  }

  export type questionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<questionScalarWhereWithAggregatesInput>
    OR?: Enumerable<questionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<questionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    difficulty?: IntNullableWithAggregatesFilter | number | null
    image_url?: StringNullableWithAggregatesFilter | string | null
    equation?: StringNullableWithAggregatesFilter | string | null
    question_text?: StringNullableWithAggregatesFilter | string | null
    answer_formula?: StringNullableWithAggregatesFilter | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    author?: StringNullableWithAggregatesFilter | string | null
  }

  export type quiz_attemptWhereInput = {
    AND?: Enumerable<quiz_attemptWhereInput>
    OR?: Enumerable<quiz_attemptWhereInput>
    NOT?: Enumerable<quiz_attemptWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    student_id?: StringFilter | string
    quiz_id?: StringFilter | string
    total_points?: IntNullableFilter | number | null
    points_scored?: IntNullableFilter | number | null
    enroll_id?: StringNullableFilter | string | null
    answer_data?: JsonNullableFilter
    question_answered_count?: IntNullableFilter | number | null
    question_unanswered_count?: IntNullableFilter | number | null
    enrollment?: XOR<EnrollmentRelationFilter, enrollmentWhereInput> | null
    quiz?: XOR<QuizRelationFilter, quizWhereInput>
    student?: XOR<StudentRelationFilter, studentWhereInput>
  }

  export type quiz_attemptOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    quiz_id?: SortOrder
    total_points?: SortOrder
    points_scored?: SortOrder
    enroll_id?: SortOrder
    answer_data?: SortOrder
    question_answered_count?: SortOrder
    question_unanswered_count?: SortOrder
    enrollment?: enrollmentOrderByWithRelationInput
    quiz?: quizOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
  }

  export type quiz_attemptWhereUniqueInput = {
    id?: string
  }

  export type quiz_attemptOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    quiz_id?: SortOrder
    total_points?: SortOrder
    points_scored?: SortOrder
    enroll_id?: SortOrder
    answer_data?: SortOrder
    question_answered_count?: SortOrder
    question_unanswered_count?: SortOrder
    _count?: quiz_attemptCountOrderByAggregateInput
    _avg?: quiz_attemptAvgOrderByAggregateInput
    _max?: quiz_attemptMaxOrderByAggregateInput
    _min?: quiz_attemptMinOrderByAggregateInput
    _sum?: quiz_attemptSumOrderByAggregateInput
  }

  export type quiz_attemptScalarWhereWithAggregatesInput = {
    AND?: Enumerable<quiz_attemptScalarWhereWithAggregatesInput>
    OR?: Enumerable<quiz_attemptScalarWhereWithAggregatesInput>
    NOT?: Enumerable<quiz_attemptScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    student_id?: StringWithAggregatesFilter | string
    quiz_id?: StringWithAggregatesFilter | string
    total_points?: IntNullableWithAggregatesFilter | number | null
    points_scored?: IntNullableWithAggregatesFilter | number | null
    enroll_id?: StringNullableWithAggregatesFilter | string | null
    answer_data?: JsonNullableWithAggregatesFilter
    question_answered_count?: IntNullableWithAggregatesFilter | number | null
    question_unanswered_count?: IntNullableWithAggregatesFilter | number | null
  }

  export type quiz_questionWhereInput = {
    AND?: Enumerable<quiz_questionWhereInput>
    OR?: Enumerable<quiz_questionWhereInput>
    NOT?: Enumerable<quiz_questionWhereInput>
    created_at?: DateTimeNullableFilter | Date | string | null
    quiz_id?: StringFilter | string
    question_id?: StringFilter | string
    question_number?: IntNullableFilter | number | null
    quiz?: XOR<QuizRelationFilter, quizWhereInput>
  }

  export type quiz_questionOrderByWithRelationInput = {
    created_at?: SortOrder
    quiz_id?: SortOrder
    question_id?: SortOrder
    question_number?: SortOrder
    quiz?: quizOrderByWithRelationInput
  }

  export type quiz_questionWhereUniqueInput = {
    quiz_id_question_id?: quiz_questionQuiz_idQuestion_idCompoundUniqueInput
  }

  export type quiz_questionOrderByWithAggregationInput = {
    created_at?: SortOrder
    quiz_id?: SortOrder
    question_id?: SortOrder
    question_number?: SortOrder
    _count?: quiz_questionCountOrderByAggregateInput
    _avg?: quiz_questionAvgOrderByAggregateInput
    _max?: quiz_questionMaxOrderByAggregateInput
    _min?: quiz_questionMinOrderByAggregateInput
    _sum?: quiz_questionSumOrderByAggregateInput
  }

  export type quiz_questionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<quiz_questionScalarWhereWithAggregatesInput>
    OR?: Enumerable<quiz_questionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<quiz_questionScalarWhereWithAggregatesInput>
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    quiz_id?: StringWithAggregatesFilter | string
    question_id?: StringWithAggregatesFilter | string
    question_number?: IntNullableWithAggregatesFilter | number | null
  }

  export type quizWhereInput = {
    AND?: Enumerable<quizWhereInput>
    OR?: Enumerable<quizWhereInput>
    NOT?: Enumerable<quizWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    author?: StringNullableFilter | string | null
    attempts?: Quiz_attemptListRelationFilter
    questions?: Quiz_questionListRelationFilter
  }

  export type quizOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    attempts?: quiz_attemptOrderByRelationAggregateInput
    questions?: quiz_questionOrderByRelationAggregateInput
  }

  export type quizWhereUniqueInput = {
    id?: string
  }

  export type quizOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    _count?: quizCountOrderByAggregateInput
    _max?: quizMaxOrderByAggregateInput
    _min?: quizMinOrderByAggregateInput
  }

  export type quizScalarWhereWithAggregatesInput = {
    AND?: Enumerable<quizScalarWhereWithAggregatesInput>
    OR?: Enumerable<quizScalarWhereWithAggregatesInput>
    NOT?: Enumerable<quizScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    author?: StringNullableWithAggregatesFilter | string | null
  }

  export type student_moduleWhereInput = {
    AND?: Enumerable<student_moduleWhereInput>
    OR?: Enumerable<student_moduleWhereInput>
    NOT?: Enumerable<student_moduleWhereInput>
    student_id?: StringFilter | string
    module_id?: StringFilter | string
    time_started?: DateTimeFilter | Date | string
    module?: XOR<ModuleRelationFilter, moduleWhereInput>
    student?: XOR<StudentRelationFilter, studentWhereInput>
  }

  export type student_moduleOrderByWithRelationInput = {
    student_id?: SortOrder
    module_id?: SortOrder
    time_started?: SortOrder
    module?: moduleOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
  }

  export type student_moduleWhereUniqueInput = {
    student_id_module_id?: student_moduleStudent_idModule_idCompoundUniqueInput
  }

  export type student_moduleOrderByWithAggregationInput = {
    student_id?: SortOrder
    module_id?: SortOrder
    time_started?: SortOrder
    _count?: student_moduleCountOrderByAggregateInput
    _max?: student_moduleMaxOrderByAggregateInput
    _min?: student_moduleMinOrderByAggregateInput
  }

  export type student_moduleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<student_moduleScalarWhereWithAggregatesInput>
    OR?: Enumerable<student_moduleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<student_moduleScalarWhereWithAggregatesInput>
    student_id?: StringWithAggregatesFilter | string
    module_id?: StringWithAggregatesFilter | string
    time_started?: DateTimeWithAggregatesFilter | Date | string
  }

  export type studentWhereInput = {
    AND?: Enumerable<studentWhereInput>
    OR?: Enumerable<studentWhereInput>
    NOT?: Enumerable<studentWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    grade_at_account_creation?: IntNullableFilter | number | null
    user_id?: StringNullableFilter | string | null
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    enrollment?: EnrollmentListRelationFilter
    quiz_attempt?: Quiz_attemptListRelationFilter
    student_module?: Student_moduleListRelationFilter
  }

  export type studentOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    grade_at_account_creation?: SortOrder
    user_id?: SortOrder
    User?: UserOrderByWithRelationInput
    enrollment?: enrollmentOrderByRelationAggregateInput
    quiz_attempt?: quiz_attemptOrderByRelationAggregateInput
    student_module?: student_moduleOrderByRelationAggregateInput
  }

  export type studentWhereUniqueInput = {
    id?: string
  }

  export type studentOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    grade_at_account_creation?: SortOrder
    user_id?: SortOrder
    _count?: studentCountOrderByAggregateInput
    _avg?: studentAvgOrderByAggregateInput
    _max?: studentMaxOrderByAggregateInput
    _min?: studentMinOrderByAggregateInput
    _sum?: studentSumOrderByAggregateInput
  }

  export type studentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<studentScalarWhereWithAggregatesInput>
    OR?: Enumerable<studentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<studentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    grade_at_account_creation?: IntNullableWithAggregatesFilter | number | null
    user_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type subjectWhereInput = {
    AND?: Enumerable<subjectWhereInput>
    OR?: Enumerable<subjectWhereInput>
    NOT?: Enumerable<subjectWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    module?: ModuleListRelationFilter
  }

  export type subjectOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    module?: moduleOrderByRelationAggregateInput
  }

  export type subjectWhereUniqueInput = {
    id?: string
  }

  export type subjectOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    _count?: subjectCountOrderByAggregateInput
    _max?: subjectMaxOrderByAggregateInput
    _min?: subjectMinOrderByAggregateInput
  }

  export type subjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<subjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subjectScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    instructor?: instructorCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    instructor?: instructorUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    instructor?: instructorUpdateManyWithoutUserInput
    student?: studentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    instructor?: instructorUncheckedUpdateManyWithoutUserInput
    student?: studentUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseCreateInput = {
    id?: string
    created_at?: Date | string | null
    instructor_id?: string | null
    course_title: string
    updated_at?: Date | string | null
    author?: string | null
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    instructor_id?: string | null
    course_title: string
    updated_at?: Date | string | null
    author?: string | null
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_id?: NullableStringFieldUpdateOperationsInput | string | null
    course_title?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUpdateManyWithoutCourseInput
  }

  export type courseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_id?: NullableStringFieldUpdateOperationsInput | string | null
    course_title?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseInput
  }

  export type courseCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    instructor_id?: string | null
    course_title: string
    updated_at?: Date | string | null
    author?: string | null
  }

  export type courseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_id?: NullableStringFieldUpdateOperationsInput | string | null
    course_title?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type courseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_id?: NullableStringFieldUpdateOperationsInput | string | null
    course_title?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type enrollmentCreateInput = {
    id?: string
    created_at?: Date | string | null
    current_grade_level?: string | null
    course?: courseCreateNestedOneWithoutEnrollmentInput
    student?: studentCreateNestedOneWithoutEnrollmentInput
    quiz_attempt?: quiz_attemptCreateNestedManyWithoutEnrollmentInput
  }

  export type enrollmentUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    student_id?: string | null
    course_id?: string | null
    current_grade_level?: string | null
    quiz_attempt?: quiz_attemptUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type enrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
    course?: courseUpdateOneWithoutEnrollmentInput
    student?: studentUpdateOneWithoutEnrollmentInput
    quiz_attempt?: quiz_attemptUpdateManyWithoutEnrollmentInput
  }

  export type enrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
    quiz_attempt?: quiz_attemptUncheckedUpdateManyWithoutEnrollmentInput
  }

  export type enrollmentCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    student_id?: string | null
    course_id?: string | null
    current_grade_level?: string | null
  }

  export type enrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type enrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type instructorCreateInput = {
    id?: string
    created_at?: Date | string | null
    User?: UserCreateNestedOneWithoutInstructorInput
  }

  export type instructorUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    user_id?: string | null
  }

  export type instructorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneWithoutInstructorInput
  }

  export type instructorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type instructorCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    user_id?: string | null
  }

  export type instructorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type instructorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lessonCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module?: moduleCreateNestedOneWithoutLessonInput
  }

  export type lessonUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    lesson_module?: string | null
  }

  export type lessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module?: moduleUpdateOneWithoutLessonInput
  }

  export type lessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_module?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lessonCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    lesson_module?: string | null
  }

  export type lessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_module?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type moduleCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_name: string
    subject?: subjectCreateNestedOneWithoutModuleInput
    lesson?: lessonCreateNestedManyWithoutModuleInput
    student_module?: student_moduleCreateNestedManyWithoutModuleInput
  }

  export type moduleUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_subject_id?: string | null
    module_name: string
    lesson?: lessonUncheckedCreateNestedManyWithoutModuleInput
    student_module?: student_moduleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type moduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
    subject?: subjectUpdateOneWithoutModuleInput
    lesson?: lessonUpdateManyWithoutModuleInput
    student_module?: student_moduleUpdateManyWithoutModuleInput
  }

  export type moduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_subject_id?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
    lesson?: lessonUncheckedUpdateManyWithoutModuleInput
    student_module?: student_moduleUncheckedUpdateManyWithoutModuleInput
  }

  export type moduleCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_subject_id?: string | null
    module_name: string
  }

  export type moduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
  }

  export type moduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_subject_id?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
  }

  export type question_topicCreateInput = {
    id?: string
    question?: questionCreateNestedOneWithoutQuestion_topicInput
    topic: topicCreateNestedOneWithoutQuestion_topicInput
  }

  export type question_topicUncheckedCreateInput = {
    id?: string
    topic_id: string
    question_id?: string | null
  }

  export type question_topicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: questionUpdateOneWithoutQuestion_topicInput
    topic?: topicUpdateOneRequiredWithoutQuestion_topicInput
  }

  export type question_topicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic_id?: StringFieldUpdateOperationsInput | string
    question_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type question_topicCreateManyInput = {
    id?: string
    topic_id: string
    question_id?: string | null
  }

  export type question_topicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type question_topicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic_id?: StringFieldUpdateOperationsInput | string
    question_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type topicCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    question_topic_name: string
    question_topic?: question_topicCreateNestedManyWithoutTopicInput
  }

  export type topicUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    question_topic_name: string
    question_topic?: question_topicUncheckedCreateNestedManyWithoutTopicInput
  }

  export type topicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_topic_name?: StringFieldUpdateOperationsInput | string
    question_topic?: question_topicUpdateManyWithoutTopicInput
  }

  export type topicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_topic_name?: StringFieldUpdateOperationsInput | string
    question_topic?: question_topicUncheckedUpdateManyWithoutTopicInput
  }

  export type topicCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    question_topic_name: string
  }

  export type topicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_topic_name?: StringFieldUpdateOperationsInput | string
  }

  export type topicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_topic_name?: StringFieldUpdateOperationsInput | string
  }

  export type questionCreateInput = {
    id?: string
    created_at?: Date | string | null
    difficulty?: number | null
    image_url?: string | null
    equation?: string | null
    question_text?: string | null
    answer_formula?: string | null
    updated_at?: Date | string | null
    author?: string | null
    question_topic?: question_topicCreateNestedManyWithoutQuestionInput
  }

  export type questionUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    difficulty?: number | null
    image_url?: string | null
    equation?: string | null
    question_text?: string | null
    answer_formula?: string | null
    updated_at?: Date | string | null
    author?: string | null
    question_topic?: question_topicUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    equation?: NullableStringFieldUpdateOperationsInput | string | null
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    answer_formula?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    question_topic?: question_topicUpdateManyWithoutQuestionInput
  }

  export type questionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    equation?: NullableStringFieldUpdateOperationsInput | string | null
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    answer_formula?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    question_topic?: question_topicUncheckedUpdateManyWithoutQuestionInput
  }

  export type questionCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    difficulty?: number | null
    image_url?: string | null
    equation?: string | null
    question_text?: string | null
    answer_formula?: string | null
    updated_at?: Date | string | null
    author?: string | null
  }

  export type questionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    equation?: NullableStringFieldUpdateOperationsInput | string | null
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    answer_formula?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type questionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    equation?: NullableStringFieldUpdateOperationsInput | string | null
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    answer_formula?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quiz_attemptCreateInput = {
    id?: string
    created_at?: Date | string | null
    total_points?: number | null
    points_scored?: number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
    enrollment?: enrollmentCreateNestedOneWithoutQuiz_attemptInput
    quiz: quizCreateNestedOneWithoutAttemptsInput
    student: studentCreateNestedOneWithoutQuiz_attemptInput
  }

  export type quiz_attemptUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    student_id: string
    quiz_id: string
    total_points?: number | null
    points_scored?: number | null
    enroll_id?: string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
  }

  export type quiz_attemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
    enrollment?: enrollmentUpdateOneWithoutQuiz_attemptInput
    quiz?: quizUpdateOneRequiredWithoutAttemptsInput
    student?: studentUpdateOneRequiredWithoutQuiz_attemptInput
  }

  export type quiz_attemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    enroll_id?: NullableStringFieldUpdateOperationsInput | string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_attemptCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    student_id: string
    quiz_id: string
    total_points?: number | null
    points_scored?: number | null
    enroll_id?: string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
  }

  export type quiz_attemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_attemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    enroll_id?: NullableStringFieldUpdateOperationsInput | string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_questionCreateInput = {
    created_at?: Date | string | null
    question_id: string
    question_number?: number | null
    quiz: quizCreateNestedOneWithoutQuestionsInput
  }

  export type quiz_questionUncheckedCreateInput = {
    created_at?: Date | string | null
    quiz_id: string
    question_id: string
    question_number?: number | null
  }

  export type quiz_questionUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_id?: StringFieldUpdateOperationsInput | string
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    quiz?: quizUpdateOneRequiredWithoutQuestionsInput
  }

  export type quiz_questionUncheckedUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz_id?: StringFieldUpdateOperationsInput | string
    question_id?: StringFieldUpdateOperationsInput | string
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_questionCreateManyInput = {
    created_at?: Date | string | null
    quiz_id: string
    question_id: string
    question_number?: number | null
  }

  export type quiz_questionUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_id?: StringFieldUpdateOperationsInput | string
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_questionUncheckedUpdateManyInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz_id?: StringFieldUpdateOperationsInput | string
    question_id?: StringFieldUpdateOperationsInput | string
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quizCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    attempts?: quiz_attemptCreateNestedManyWithoutQuizInput
    questions?: quiz_questionCreateNestedManyWithoutQuizInput
  }

  export type quizUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    attempts?: quiz_attemptUncheckedCreateNestedManyWithoutQuizInput
    questions?: quiz_questionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type quizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: quiz_attemptUpdateManyWithoutQuizInput
    questions?: quiz_questionUpdateManyWithoutQuizInput
  }

  export type quizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: quiz_attemptUncheckedUpdateManyWithoutQuizInput
    questions?: quiz_questionUncheckedUpdateManyWithoutQuizInput
  }

  export type quizCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
  }

  export type quizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_moduleCreateInput = {
    time_started?: Date | string
    module: moduleCreateNestedOneWithoutStudent_moduleInput
    student: studentCreateNestedOneWithoutStudent_moduleInput
  }

  export type student_moduleUncheckedCreateInput = {
    student_id: string
    module_id: string
    time_started?: Date | string
  }

  export type student_moduleUpdateInput = {
    time_started?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: moduleUpdateOneRequiredWithoutStudent_moduleInput
    student?: studentUpdateOneRequiredWithoutStudent_moduleInput
  }

  export type student_moduleUncheckedUpdateInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    module_id?: StringFieldUpdateOperationsInput | string
    time_started?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_moduleCreateManyInput = {
    student_id: string
    module_id: string
    time_started?: Date | string
  }

  export type student_moduleUpdateManyMutationInput = {
    time_started?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_moduleUncheckedUpdateManyInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    module_id?: StringFieldUpdateOperationsInput | string
    time_started?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentCreateInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    User?: UserCreateNestedOneWithoutStudentInput
    enrollment?: enrollmentCreateNestedManyWithoutStudentInput
    quiz_attempt?: quiz_attemptCreateNestedManyWithoutStudentInput
    student_module?: student_moduleCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    user_id?: string | null
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutStudentInput
    quiz_attempt?: quiz_attemptUncheckedCreateNestedManyWithoutStudentInput
    student_module?: student_moduleUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneWithoutStudentInput
    enrollment?: enrollmentUpdateManyWithoutStudentInput
    quiz_attempt?: quiz_attemptUpdateManyWithoutStudentInput
    student_module?: student_moduleUpdateManyWithoutStudentInput
  }

  export type studentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUncheckedUpdateManyWithoutStudentInput
    quiz_attempt?: quiz_attemptUncheckedUpdateManyWithoutStudentInput
    student_module?: student_moduleUncheckedUpdateManyWithoutStudentInput
  }

  export type studentCreateManyInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    user_id?: string | null
  }

  export type studentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type studentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subjectCreateInput = {
    id?: string
    created_at?: Date | string | null
    module?: moduleCreateNestedManyWithoutSubjectInput
  }

  export type subjectUncheckedCreateInput = {
    id?: string
    created_at?: Date | string | null
    module?: moduleUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    module?: moduleUpdateManyWithoutSubjectInput
  }

  export type subjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    module?: moduleUncheckedUpdateManyWithoutSubjectInput
  }

  export type subjectCreateManyInput = {
    id?: string
    created_at?: Date | string | null
  }

  export type subjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    oauth_token_secret?: SortOrder
    oauth_token?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type InstructorListRelationFilter = {
    every?: instructorWhereInput
    some?: instructorWhereInput
    none?: instructorWhereInput
  }

  export type StudentListRelationFilter = {
    every?: studentWhereInput
    some?: studentWhereInput
    none?: studentWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type instructorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnrollmentListRelationFilter = {
    every?: enrollmentWhereInput
    some?: enrollmentWhereInput
    none?: enrollmentWhereInput
  }

  export type enrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type courseCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    instructor_id?: SortOrder
    course_title?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
  }

  export type courseMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    instructor_id?: SortOrder
    course_title?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
  }

  export type courseMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    instructor_id?: SortOrder
    course_title?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
  }

  export type CourseRelationFilter = {
    is?: courseWhereInput | null
    isNot?: courseWhereInput | null
  }

  export type StudentRelationFilter = {
    is?: studentWhereInput | null
    isNot?: studentWhereInput | null
  }

  export type Quiz_attemptListRelationFilter = {
    every?: quiz_attemptWhereInput
    some?: quiz_attemptWhereInput
    none?: quiz_attemptWhereInput
  }

  export type quiz_attemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type enrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    course_id?: SortOrder
    current_grade_level?: SortOrder
  }

  export type enrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    course_id?: SortOrder
    current_grade_level?: SortOrder
  }

  export type enrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    course_id?: SortOrder
    current_grade_level?: SortOrder
  }

  export type instructorCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type instructorMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type instructorMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type ModuleRelationFilter = {
    is?: moduleWhereInput | null
    isNot?: moduleWhereInput | null
  }

  export type lessonCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    lesson_module?: SortOrder
  }

  export type lessonMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    lesson_module?: SortOrder
  }

  export type lessonMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    lesson_module?: SortOrder
  }

  export type SubjectRelationFilter = {
    is?: subjectWhereInput | null
    isNot?: subjectWhereInput | null
  }

  export type LessonListRelationFilter = {
    every?: lessonWhereInput
    some?: lessonWhereInput
    none?: lessonWhereInput
  }

  export type Student_moduleListRelationFilter = {
    every?: student_moduleWhereInput
    some?: student_moduleWhereInput
    none?: student_moduleWhereInput
  }

  export type lessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_moduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type moduleCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    module_subject_id?: SortOrder
    module_name?: SortOrder
  }

  export type moduleMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    module_subject_id?: SortOrder
    module_name?: SortOrder
  }

  export type moduleMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
    module_subject_id?: SortOrder
    module_name?: SortOrder
  }

  export type QuestionRelationFilter = {
    is?: questionWhereInput | null
    isNot?: questionWhereInput | null
  }

  export type TopicRelationFilter = {
    is?: topicWhereInput
    isNot?: topicWhereInput
  }

  export type question_topicCountOrderByAggregateInput = {
    id?: SortOrder
    topic_id?: SortOrder
    question_id?: SortOrder
  }

  export type question_topicMaxOrderByAggregateInput = {
    id?: SortOrder
    topic_id?: SortOrder
    question_id?: SortOrder
  }

  export type question_topicMinOrderByAggregateInput = {
    id?: SortOrder
    topic_id?: SortOrder
    question_id?: SortOrder
  }

  export type Question_topicListRelationFilter = {
    every?: question_topicWhereInput
    some?: question_topicWhereInput
    none?: question_topicWhereInput
  }

  export type question_topicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type topicCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    question_topic_name?: SortOrder
  }

  export type topicMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    question_topic_name?: SortOrder
  }

  export type topicMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    question_topic_name?: SortOrder
  }

  export type questionCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    difficulty?: SortOrder
    image_url?: SortOrder
    equation?: SortOrder
    question_text?: SortOrder
    answer_formula?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
  }

  export type questionAvgOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type questionMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    difficulty?: SortOrder
    image_url?: SortOrder
    equation?: SortOrder
    question_text?: SortOrder
    answer_formula?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
  }

  export type questionMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    difficulty?: SortOrder
    image_url?: SortOrder
    equation?: SortOrder
    question_text?: SortOrder
    answer_formula?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
  }

  export type questionSumOrderByAggregateInput = {
    difficulty?: SortOrder
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type EnrollmentRelationFilter = {
    is?: enrollmentWhereInput | null
    isNot?: enrollmentWhereInput | null
  }

  export type QuizRelationFilter = {
    is?: quizWhereInput
    isNot?: quizWhereInput
  }

  export type quiz_attemptCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    quiz_id?: SortOrder
    total_points?: SortOrder
    points_scored?: SortOrder
    enroll_id?: SortOrder
    answer_data?: SortOrder
    question_answered_count?: SortOrder
    question_unanswered_count?: SortOrder
  }

  export type quiz_attemptAvgOrderByAggregateInput = {
    total_points?: SortOrder
    points_scored?: SortOrder
    question_answered_count?: SortOrder
    question_unanswered_count?: SortOrder
  }

  export type quiz_attemptMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    quiz_id?: SortOrder
    total_points?: SortOrder
    points_scored?: SortOrder
    enroll_id?: SortOrder
    question_answered_count?: SortOrder
    question_unanswered_count?: SortOrder
  }

  export type quiz_attemptMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    student_id?: SortOrder
    quiz_id?: SortOrder
    total_points?: SortOrder
    points_scored?: SortOrder
    enroll_id?: SortOrder
    question_answered_count?: SortOrder
    question_unanswered_count?: SortOrder
  }

  export type quiz_attemptSumOrderByAggregateInput = {
    total_points?: SortOrder
    points_scored?: SortOrder
    question_answered_count?: SortOrder
    question_unanswered_count?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type quiz_questionQuiz_idQuestion_idCompoundUniqueInput = {
    quiz_id: string
    question_id: string
  }

  export type quiz_questionCountOrderByAggregateInput = {
    created_at?: SortOrder
    quiz_id?: SortOrder
    question_id?: SortOrder
    question_number?: SortOrder
  }

  export type quiz_questionAvgOrderByAggregateInput = {
    question_number?: SortOrder
  }

  export type quiz_questionMaxOrderByAggregateInput = {
    created_at?: SortOrder
    quiz_id?: SortOrder
    question_id?: SortOrder
    question_number?: SortOrder
  }

  export type quiz_questionMinOrderByAggregateInput = {
    created_at?: SortOrder
    quiz_id?: SortOrder
    question_id?: SortOrder
    question_number?: SortOrder
  }

  export type quiz_questionSumOrderByAggregateInput = {
    question_number?: SortOrder
  }

  export type Quiz_questionListRelationFilter = {
    every?: quiz_questionWhereInput
    some?: quiz_questionWhereInput
    none?: quiz_questionWhereInput
  }

  export type quiz_questionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quizCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
  }

  export type quizMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
  }

  export type quizMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    author?: SortOrder
  }

  export type student_moduleStudent_idModule_idCompoundUniqueInput = {
    student_id: string
    module_id: string
  }

  export type student_moduleCountOrderByAggregateInput = {
    student_id?: SortOrder
    module_id?: SortOrder
    time_started?: SortOrder
  }

  export type student_moduleMaxOrderByAggregateInput = {
    student_id?: SortOrder
    module_id?: SortOrder
    time_started?: SortOrder
  }

  export type student_moduleMinOrderByAggregateInput = {
    student_id?: SortOrder
    module_id?: SortOrder
    time_started?: SortOrder
  }

  export type studentCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    grade_at_account_creation?: SortOrder
    user_id?: SortOrder
  }

  export type studentAvgOrderByAggregateInput = {
    grade_at_account_creation?: SortOrder
  }

  export type studentMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    grade_at_account_creation?: SortOrder
    user_id?: SortOrder
  }

  export type studentMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    grade_at_account_creation?: SortOrder
    user_id?: SortOrder
  }

  export type studentSumOrderByAggregateInput = {
    grade_at_account_creation?: SortOrder
  }

  export type ModuleListRelationFilter = {
    every?: moduleWhereInput
    some?: moduleWhereInput
    none?: moduleWhereInput
  }

  export type moduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
  }

  export type subjectMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
  }

  export type subjectMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type instructorCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<instructorCreateWithoutUserInput>, Enumerable<instructorUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<instructorCreateOrConnectWithoutUserInput>
    createMany?: instructorCreateManyUserInputEnvelope
    connect?: Enumerable<instructorWhereUniqueInput>
  }

  export type studentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<studentCreateWithoutUserInput>, Enumerable<studentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<studentCreateOrConnectWithoutUserInput>
    createMany?: studentCreateManyUserInputEnvelope
    connect?: Enumerable<studentWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type instructorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<instructorCreateWithoutUserInput>, Enumerable<instructorUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<instructorCreateOrConnectWithoutUserInput>
    createMany?: instructorCreateManyUserInputEnvelope
    connect?: Enumerable<instructorWhereUniqueInput>
  }

  export type studentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<studentCreateWithoutUserInput>, Enumerable<studentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<studentCreateOrConnectWithoutUserInput>
    createMany?: studentCreateManyUserInputEnvelope
    connect?: Enumerable<studentWhereUniqueInput>
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type instructorUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<instructorCreateWithoutUserInput>, Enumerable<instructorUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<instructorCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<instructorUpsertWithWhereUniqueWithoutUserInput>
    createMany?: instructorCreateManyUserInputEnvelope
    set?: Enumerable<instructorWhereUniqueInput>
    disconnect?: Enumerable<instructorWhereUniqueInput>
    delete?: Enumerable<instructorWhereUniqueInput>
    connect?: Enumerable<instructorWhereUniqueInput>
    update?: Enumerable<instructorUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<instructorUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<instructorScalarWhereInput>
  }

  export type studentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<studentCreateWithoutUserInput>, Enumerable<studentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<studentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<studentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: studentCreateManyUserInputEnvelope
    set?: Enumerable<studentWhereUniqueInput>
    disconnect?: Enumerable<studentWhereUniqueInput>
    delete?: Enumerable<studentWhereUniqueInput>
    connect?: Enumerable<studentWhereUniqueInput>
    update?: Enumerable<studentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<studentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<studentScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type instructorUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<instructorCreateWithoutUserInput>, Enumerable<instructorUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<instructorCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<instructorUpsertWithWhereUniqueWithoutUserInput>
    createMany?: instructorCreateManyUserInputEnvelope
    set?: Enumerable<instructorWhereUniqueInput>
    disconnect?: Enumerable<instructorWhereUniqueInput>
    delete?: Enumerable<instructorWhereUniqueInput>
    connect?: Enumerable<instructorWhereUniqueInput>
    update?: Enumerable<instructorUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<instructorUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<instructorScalarWhereInput>
  }

  export type studentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<studentCreateWithoutUserInput>, Enumerable<studentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<studentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<studentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: studentCreateManyUserInputEnvelope
    set?: Enumerable<studentWhereUniqueInput>
    disconnect?: Enumerable<studentWhereUniqueInput>
    delete?: Enumerable<studentWhereUniqueInput>
    connect?: Enumerable<studentWhereUniqueInput>
    update?: Enumerable<studentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<studentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<studentScalarWhereInput>
  }

  export type enrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<enrollmentCreateWithoutCourseInput>, Enumerable<enrollmentUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<enrollmentCreateOrConnectWithoutCourseInput>
    createMany?: enrollmentCreateManyCourseInputEnvelope
    connect?: Enumerable<enrollmentWhereUniqueInput>
  }

  export type enrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<enrollmentCreateWithoutCourseInput>, Enumerable<enrollmentUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<enrollmentCreateOrConnectWithoutCourseInput>
    createMany?: enrollmentCreateManyCourseInputEnvelope
    connect?: Enumerable<enrollmentWhereUniqueInput>
  }

  export type enrollmentUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<enrollmentCreateWithoutCourseInput>, Enumerable<enrollmentUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<enrollmentCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<enrollmentUpsertWithWhereUniqueWithoutCourseInput>
    createMany?: enrollmentCreateManyCourseInputEnvelope
    set?: Enumerable<enrollmentWhereUniqueInput>
    disconnect?: Enumerable<enrollmentWhereUniqueInput>
    delete?: Enumerable<enrollmentWhereUniqueInput>
    connect?: Enumerable<enrollmentWhereUniqueInput>
    update?: Enumerable<enrollmentUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<enrollmentUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<enrollmentScalarWhereInput>
  }

  export type enrollmentUncheckedUpdateManyWithoutCourseInput = {
    create?: XOR<Enumerable<enrollmentCreateWithoutCourseInput>, Enumerable<enrollmentUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<enrollmentCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<enrollmentUpsertWithWhereUniqueWithoutCourseInput>
    createMany?: enrollmentCreateManyCourseInputEnvelope
    set?: Enumerable<enrollmentWhereUniqueInput>
    disconnect?: Enumerable<enrollmentWhereUniqueInput>
    delete?: Enumerable<enrollmentWhereUniqueInput>
    connect?: Enumerable<enrollmentWhereUniqueInput>
    update?: Enumerable<enrollmentUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<enrollmentUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<enrollmentScalarWhereInput>
  }

  export type courseCreateNestedOneWithoutEnrollmentInput = {
    create?: XOR<courseCreateWithoutEnrollmentInput, courseUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: courseCreateOrConnectWithoutEnrollmentInput
    connect?: courseWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutEnrollmentInput = {
    create?: XOR<studentCreateWithoutEnrollmentInput, studentUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: studentCreateOrConnectWithoutEnrollmentInput
    connect?: studentWhereUniqueInput
  }

  export type quiz_attemptCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutEnrollmentInput>, Enumerable<quiz_attemptUncheckedCreateWithoutEnrollmentInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutEnrollmentInput>
    createMany?: quiz_attemptCreateManyEnrollmentInputEnvelope
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
  }

  export type quiz_attemptUncheckedCreateNestedManyWithoutEnrollmentInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutEnrollmentInput>, Enumerable<quiz_attemptUncheckedCreateWithoutEnrollmentInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutEnrollmentInput>
    createMany?: quiz_attemptCreateManyEnrollmentInputEnvelope
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
  }

  export type courseUpdateOneWithoutEnrollmentInput = {
    create?: XOR<courseCreateWithoutEnrollmentInput, courseUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: courseCreateOrConnectWithoutEnrollmentInput
    upsert?: courseUpsertWithoutEnrollmentInput
    disconnect?: boolean
    delete?: boolean
    connect?: courseWhereUniqueInput
    update?: XOR<courseUpdateWithoutEnrollmentInput, courseUncheckedUpdateWithoutEnrollmentInput>
  }

  export type studentUpdateOneWithoutEnrollmentInput = {
    create?: XOR<studentCreateWithoutEnrollmentInput, studentUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: studentCreateOrConnectWithoutEnrollmentInput
    upsert?: studentUpsertWithoutEnrollmentInput
    disconnect?: boolean
    delete?: boolean
    connect?: studentWhereUniqueInput
    update?: XOR<studentUpdateWithoutEnrollmentInput, studentUncheckedUpdateWithoutEnrollmentInput>
  }

  export type quiz_attemptUpdateManyWithoutEnrollmentInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutEnrollmentInput>, Enumerable<quiz_attemptUncheckedCreateWithoutEnrollmentInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutEnrollmentInput>
    upsert?: Enumerable<quiz_attemptUpsertWithWhereUniqueWithoutEnrollmentInput>
    createMany?: quiz_attemptCreateManyEnrollmentInputEnvelope
    set?: Enumerable<quiz_attemptWhereUniqueInput>
    disconnect?: Enumerable<quiz_attemptWhereUniqueInput>
    delete?: Enumerable<quiz_attemptWhereUniqueInput>
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
    update?: Enumerable<quiz_attemptUpdateWithWhereUniqueWithoutEnrollmentInput>
    updateMany?: Enumerable<quiz_attemptUpdateManyWithWhereWithoutEnrollmentInput>
    deleteMany?: Enumerable<quiz_attemptScalarWhereInput>
  }

  export type quiz_attemptUncheckedUpdateManyWithoutEnrollmentInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutEnrollmentInput>, Enumerable<quiz_attemptUncheckedCreateWithoutEnrollmentInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutEnrollmentInput>
    upsert?: Enumerable<quiz_attemptUpsertWithWhereUniqueWithoutEnrollmentInput>
    createMany?: quiz_attemptCreateManyEnrollmentInputEnvelope
    set?: Enumerable<quiz_attemptWhereUniqueInput>
    disconnect?: Enumerable<quiz_attemptWhereUniqueInput>
    delete?: Enumerable<quiz_attemptWhereUniqueInput>
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
    update?: Enumerable<quiz_attemptUpdateWithWhereUniqueWithoutEnrollmentInput>
    updateMany?: Enumerable<quiz_attemptUpdateManyWithWhereWithoutEnrollmentInput>
    deleteMany?: Enumerable<quiz_attemptScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutInstructorInput = {
    create?: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructorInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutInstructorInput = {
    create?: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructorInput
    upsert?: UserUpsertWithoutInstructorInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInstructorInput, UserUncheckedUpdateWithoutInstructorInput>
  }

  export type moduleCreateNestedOneWithoutLessonInput = {
    create?: XOR<moduleCreateWithoutLessonInput, moduleUncheckedCreateWithoutLessonInput>
    connectOrCreate?: moduleCreateOrConnectWithoutLessonInput
    connect?: moduleWhereUniqueInput
  }

  export type moduleUpdateOneWithoutLessonInput = {
    create?: XOR<moduleCreateWithoutLessonInput, moduleUncheckedCreateWithoutLessonInput>
    connectOrCreate?: moduleCreateOrConnectWithoutLessonInput
    upsert?: moduleUpsertWithoutLessonInput
    disconnect?: boolean
    delete?: boolean
    connect?: moduleWhereUniqueInput
    update?: XOR<moduleUpdateWithoutLessonInput, moduleUncheckedUpdateWithoutLessonInput>
  }

  export type subjectCreateNestedOneWithoutModuleInput = {
    create?: XOR<subjectCreateWithoutModuleInput, subjectUncheckedCreateWithoutModuleInput>
    connectOrCreate?: subjectCreateOrConnectWithoutModuleInput
    connect?: subjectWhereUniqueInput
  }

  export type lessonCreateNestedManyWithoutModuleInput = {
    create?: XOR<Enumerable<lessonCreateWithoutModuleInput>, Enumerable<lessonUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<lessonCreateOrConnectWithoutModuleInput>
    createMany?: lessonCreateManyModuleInputEnvelope
    connect?: Enumerable<lessonWhereUniqueInput>
  }

  export type student_moduleCreateNestedManyWithoutModuleInput = {
    create?: XOR<Enumerable<student_moduleCreateWithoutModuleInput>, Enumerable<student_moduleUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<student_moduleCreateOrConnectWithoutModuleInput>
    createMany?: student_moduleCreateManyModuleInputEnvelope
    connect?: Enumerable<student_moduleWhereUniqueInput>
  }

  export type lessonUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<Enumerable<lessonCreateWithoutModuleInput>, Enumerable<lessonUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<lessonCreateOrConnectWithoutModuleInput>
    createMany?: lessonCreateManyModuleInputEnvelope
    connect?: Enumerable<lessonWhereUniqueInput>
  }

  export type student_moduleUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<Enumerable<student_moduleCreateWithoutModuleInput>, Enumerable<student_moduleUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<student_moduleCreateOrConnectWithoutModuleInput>
    createMany?: student_moduleCreateManyModuleInputEnvelope
    connect?: Enumerable<student_moduleWhereUniqueInput>
  }

  export type subjectUpdateOneWithoutModuleInput = {
    create?: XOR<subjectCreateWithoutModuleInput, subjectUncheckedCreateWithoutModuleInput>
    connectOrCreate?: subjectCreateOrConnectWithoutModuleInput
    upsert?: subjectUpsertWithoutModuleInput
    disconnect?: boolean
    delete?: boolean
    connect?: subjectWhereUniqueInput
    update?: XOR<subjectUpdateWithoutModuleInput, subjectUncheckedUpdateWithoutModuleInput>
  }

  export type lessonUpdateManyWithoutModuleInput = {
    create?: XOR<Enumerable<lessonCreateWithoutModuleInput>, Enumerable<lessonUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<lessonCreateOrConnectWithoutModuleInput>
    upsert?: Enumerable<lessonUpsertWithWhereUniqueWithoutModuleInput>
    createMany?: lessonCreateManyModuleInputEnvelope
    set?: Enumerable<lessonWhereUniqueInput>
    disconnect?: Enumerable<lessonWhereUniqueInput>
    delete?: Enumerable<lessonWhereUniqueInput>
    connect?: Enumerable<lessonWhereUniqueInput>
    update?: Enumerable<lessonUpdateWithWhereUniqueWithoutModuleInput>
    updateMany?: Enumerable<lessonUpdateManyWithWhereWithoutModuleInput>
    deleteMany?: Enumerable<lessonScalarWhereInput>
  }

  export type student_moduleUpdateManyWithoutModuleInput = {
    create?: XOR<Enumerable<student_moduleCreateWithoutModuleInput>, Enumerable<student_moduleUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<student_moduleCreateOrConnectWithoutModuleInput>
    upsert?: Enumerable<student_moduleUpsertWithWhereUniqueWithoutModuleInput>
    createMany?: student_moduleCreateManyModuleInputEnvelope
    set?: Enumerable<student_moduleWhereUniqueInput>
    disconnect?: Enumerable<student_moduleWhereUniqueInput>
    delete?: Enumerable<student_moduleWhereUniqueInput>
    connect?: Enumerable<student_moduleWhereUniqueInput>
    update?: Enumerable<student_moduleUpdateWithWhereUniqueWithoutModuleInput>
    updateMany?: Enumerable<student_moduleUpdateManyWithWhereWithoutModuleInput>
    deleteMany?: Enumerable<student_moduleScalarWhereInput>
  }

  export type lessonUncheckedUpdateManyWithoutModuleInput = {
    create?: XOR<Enumerable<lessonCreateWithoutModuleInput>, Enumerable<lessonUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<lessonCreateOrConnectWithoutModuleInput>
    upsert?: Enumerable<lessonUpsertWithWhereUniqueWithoutModuleInput>
    createMany?: lessonCreateManyModuleInputEnvelope
    set?: Enumerable<lessonWhereUniqueInput>
    disconnect?: Enumerable<lessonWhereUniqueInput>
    delete?: Enumerable<lessonWhereUniqueInput>
    connect?: Enumerable<lessonWhereUniqueInput>
    update?: Enumerable<lessonUpdateWithWhereUniqueWithoutModuleInput>
    updateMany?: Enumerable<lessonUpdateManyWithWhereWithoutModuleInput>
    deleteMany?: Enumerable<lessonScalarWhereInput>
  }

  export type student_moduleUncheckedUpdateManyWithoutModuleInput = {
    create?: XOR<Enumerable<student_moduleCreateWithoutModuleInput>, Enumerable<student_moduleUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<student_moduleCreateOrConnectWithoutModuleInput>
    upsert?: Enumerable<student_moduleUpsertWithWhereUniqueWithoutModuleInput>
    createMany?: student_moduleCreateManyModuleInputEnvelope
    set?: Enumerable<student_moduleWhereUniqueInput>
    disconnect?: Enumerable<student_moduleWhereUniqueInput>
    delete?: Enumerable<student_moduleWhereUniqueInput>
    connect?: Enumerable<student_moduleWhereUniqueInput>
    update?: Enumerable<student_moduleUpdateWithWhereUniqueWithoutModuleInput>
    updateMany?: Enumerable<student_moduleUpdateManyWithWhereWithoutModuleInput>
    deleteMany?: Enumerable<student_moduleScalarWhereInput>
  }

  export type questionCreateNestedOneWithoutQuestion_topicInput = {
    create?: XOR<questionCreateWithoutQuestion_topicInput, questionUncheckedCreateWithoutQuestion_topicInput>
    connectOrCreate?: questionCreateOrConnectWithoutQuestion_topicInput
    connect?: questionWhereUniqueInput
  }

  export type topicCreateNestedOneWithoutQuestion_topicInput = {
    create?: XOR<topicCreateWithoutQuestion_topicInput, topicUncheckedCreateWithoutQuestion_topicInput>
    connectOrCreate?: topicCreateOrConnectWithoutQuestion_topicInput
    connect?: topicWhereUniqueInput
  }

  export type questionUpdateOneWithoutQuestion_topicInput = {
    create?: XOR<questionCreateWithoutQuestion_topicInput, questionUncheckedCreateWithoutQuestion_topicInput>
    connectOrCreate?: questionCreateOrConnectWithoutQuestion_topicInput
    upsert?: questionUpsertWithoutQuestion_topicInput
    disconnect?: boolean
    delete?: boolean
    connect?: questionWhereUniqueInput
    update?: XOR<questionUpdateWithoutQuestion_topicInput, questionUncheckedUpdateWithoutQuestion_topicInput>
  }

  export type topicUpdateOneRequiredWithoutQuestion_topicInput = {
    create?: XOR<topicCreateWithoutQuestion_topicInput, topicUncheckedCreateWithoutQuestion_topicInput>
    connectOrCreate?: topicCreateOrConnectWithoutQuestion_topicInput
    upsert?: topicUpsertWithoutQuestion_topicInput
    connect?: topicWhereUniqueInput
    update?: XOR<topicUpdateWithoutQuestion_topicInput, topicUncheckedUpdateWithoutQuestion_topicInput>
  }

  export type question_topicCreateNestedManyWithoutTopicInput = {
    create?: XOR<Enumerable<question_topicCreateWithoutTopicInput>, Enumerable<question_topicUncheckedCreateWithoutTopicInput>>
    connectOrCreate?: Enumerable<question_topicCreateOrConnectWithoutTopicInput>
    createMany?: question_topicCreateManyTopicInputEnvelope
    connect?: Enumerable<question_topicWhereUniqueInput>
  }

  export type question_topicUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<Enumerable<question_topicCreateWithoutTopicInput>, Enumerable<question_topicUncheckedCreateWithoutTopicInput>>
    connectOrCreate?: Enumerable<question_topicCreateOrConnectWithoutTopicInput>
    createMany?: question_topicCreateManyTopicInputEnvelope
    connect?: Enumerable<question_topicWhereUniqueInput>
  }

  export type question_topicUpdateManyWithoutTopicInput = {
    create?: XOR<Enumerable<question_topicCreateWithoutTopicInput>, Enumerable<question_topicUncheckedCreateWithoutTopicInput>>
    connectOrCreate?: Enumerable<question_topicCreateOrConnectWithoutTopicInput>
    upsert?: Enumerable<question_topicUpsertWithWhereUniqueWithoutTopicInput>
    createMany?: question_topicCreateManyTopicInputEnvelope
    set?: Enumerable<question_topicWhereUniqueInput>
    disconnect?: Enumerable<question_topicWhereUniqueInput>
    delete?: Enumerable<question_topicWhereUniqueInput>
    connect?: Enumerable<question_topicWhereUniqueInput>
    update?: Enumerable<question_topicUpdateWithWhereUniqueWithoutTopicInput>
    updateMany?: Enumerable<question_topicUpdateManyWithWhereWithoutTopicInput>
    deleteMany?: Enumerable<question_topicScalarWhereInput>
  }

  export type question_topicUncheckedUpdateManyWithoutTopicInput = {
    create?: XOR<Enumerable<question_topicCreateWithoutTopicInput>, Enumerable<question_topicUncheckedCreateWithoutTopicInput>>
    connectOrCreate?: Enumerable<question_topicCreateOrConnectWithoutTopicInput>
    upsert?: Enumerable<question_topicUpsertWithWhereUniqueWithoutTopicInput>
    createMany?: question_topicCreateManyTopicInputEnvelope
    set?: Enumerable<question_topicWhereUniqueInput>
    disconnect?: Enumerable<question_topicWhereUniqueInput>
    delete?: Enumerable<question_topicWhereUniqueInput>
    connect?: Enumerable<question_topicWhereUniqueInput>
    update?: Enumerable<question_topicUpdateWithWhereUniqueWithoutTopicInput>
    updateMany?: Enumerable<question_topicUpdateManyWithWhereWithoutTopicInput>
    deleteMany?: Enumerable<question_topicScalarWhereInput>
  }

  export type question_topicCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<question_topicCreateWithoutQuestionInput>, Enumerable<question_topicUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<question_topicCreateOrConnectWithoutQuestionInput>
    createMany?: question_topicCreateManyQuestionInputEnvelope
    connect?: Enumerable<question_topicWhereUniqueInput>
  }

  export type question_topicUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<question_topicCreateWithoutQuestionInput>, Enumerable<question_topicUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<question_topicCreateOrConnectWithoutQuestionInput>
    createMany?: question_topicCreateManyQuestionInputEnvelope
    connect?: Enumerable<question_topicWhereUniqueInput>
  }

  export type question_topicUpdateManyWithoutQuestionInput = {
    create?: XOR<Enumerable<question_topicCreateWithoutQuestionInput>, Enumerable<question_topicUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<question_topicCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<question_topicUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: question_topicCreateManyQuestionInputEnvelope
    set?: Enumerable<question_topicWhereUniqueInput>
    disconnect?: Enumerable<question_topicWhereUniqueInput>
    delete?: Enumerable<question_topicWhereUniqueInput>
    connect?: Enumerable<question_topicWhereUniqueInput>
    update?: Enumerable<question_topicUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<question_topicUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<question_topicScalarWhereInput>
  }

  export type question_topicUncheckedUpdateManyWithoutQuestionInput = {
    create?: XOR<Enumerable<question_topicCreateWithoutQuestionInput>, Enumerable<question_topicUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<question_topicCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<question_topicUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: question_topicCreateManyQuestionInputEnvelope
    set?: Enumerable<question_topicWhereUniqueInput>
    disconnect?: Enumerable<question_topicWhereUniqueInput>
    delete?: Enumerable<question_topicWhereUniqueInput>
    connect?: Enumerable<question_topicWhereUniqueInput>
    update?: Enumerable<question_topicUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<question_topicUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<question_topicScalarWhereInput>
  }

  export type enrollmentCreateNestedOneWithoutQuiz_attemptInput = {
    create?: XOR<enrollmentCreateWithoutQuiz_attemptInput, enrollmentUncheckedCreateWithoutQuiz_attemptInput>
    connectOrCreate?: enrollmentCreateOrConnectWithoutQuiz_attemptInput
    connect?: enrollmentWhereUniqueInput
  }

  export type quizCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<quizCreateWithoutAttemptsInput, quizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: quizCreateOrConnectWithoutAttemptsInput
    connect?: quizWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutQuiz_attemptInput = {
    create?: XOR<studentCreateWithoutQuiz_attemptInput, studentUncheckedCreateWithoutQuiz_attemptInput>
    connectOrCreate?: studentCreateOrConnectWithoutQuiz_attemptInput
    connect?: studentWhereUniqueInput
  }

  export type enrollmentUpdateOneWithoutQuiz_attemptInput = {
    create?: XOR<enrollmentCreateWithoutQuiz_attemptInput, enrollmentUncheckedCreateWithoutQuiz_attemptInput>
    connectOrCreate?: enrollmentCreateOrConnectWithoutQuiz_attemptInput
    upsert?: enrollmentUpsertWithoutQuiz_attemptInput
    disconnect?: boolean
    delete?: boolean
    connect?: enrollmentWhereUniqueInput
    update?: XOR<enrollmentUpdateWithoutQuiz_attemptInput, enrollmentUncheckedUpdateWithoutQuiz_attemptInput>
  }

  export type quizUpdateOneRequiredWithoutAttemptsInput = {
    create?: XOR<quizCreateWithoutAttemptsInput, quizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: quizCreateOrConnectWithoutAttemptsInput
    upsert?: quizUpsertWithoutAttemptsInput
    connect?: quizWhereUniqueInput
    update?: XOR<quizUpdateWithoutAttemptsInput, quizUncheckedUpdateWithoutAttemptsInput>
  }

  export type studentUpdateOneRequiredWithoutQuiz_attemptInput = {
    create?: XOR<studentCreateWithoutQuiz_attemptInput, studentUncheckedCreateWithoutQuiz_attemptInput>
    connectOrCreate?: studentCreateOrConnectWithoutQuiz_attemptInput
    upsert?: studentUpsertWithoutQuiz_attemptInput
    connect?: studentWhereUniqueInput
    update?: XOR<studentUpdateWithoutQuiz_attemptInput, studentUncheckedUpdateWithoutQuiz_attemptInput>
  }

  export type quizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<quizCreateWithoutQuestionsInput, quizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: quizCreateOrConnectWithoutQuestionsInput
    connect?: quizWhereUniqueInput
  }

  export type quizUpdateOneRequiredWithoutQuestionsInput = {
    create?: XOR<quizCreateWithoutQuestionsInput, quizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: quizCreateOrConnectWithoutQuestionsInput
    upsert?: quizUpsertWithoutQuestionsInput
    connect?: quizWhereUniqueInput
    update?: XOR<quizUpdateWithoutQuestionsInput, quizUncheckedUpdateWithoutQuestionsInput>
  }

  export type quiz_attemptCreateNestedManyWithoutQuizInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutQuizInput>, Enumerable<quiz_attemptUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutQuizInput>
    createMany?: quiz_attemptCreateManyQuizInputEnvelope
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
  }

  export type quiz_questionCreateNestedManyWithoutQuizInput = {
    create?: XOR<Enumerable<quiz_questionCreateWithoutQuizInput>, Enumerable<quiz_questionUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<quiz_questionCreateOrConnectWithoutQuizInput>
    createMany?: quiz_questionCreateManyQuizInputEnvelope
    connect?: Enumerable<quiz_questionWhereUniqueInput>
  }

  export type quiz_attemptUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutQuizInput>, Enumerable<quiz_attemptUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutQuizInput>
    createMany?: quiz_attemptCreateManyQuizInputEnvelope
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
  }

  export type quiz_questionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<Enumerable<quiz_questionCreateWithoutQuizInput>, Enumerable<quiz_questionUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<quiz_questionCreateOrConnectWithoutQuizInput>
    createMany?: quiz_questionCreateManyQuizInputEnvelope
    connect?: Enumerable<quiz_questionWhereUniqueInput>
  }

  export type quiz_attemptUpdateManyWithoutQuizInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutQuizInput>, Enumerable<quiz_attemptUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutQuizInput>
    upsert?: Enumerable<quiz_attemptUpsertWithWhereUniqueWithoutQuizInput>
    createMany?: quiz_attemptCreateManyQuizInputEnvelope
    set?: Enumerable<quiz_attemptWhereUniqueInput>
    disconnect?: Enumerable<quiz_attemptWhereUniqueInput>
    delete?: Enumerable<quiz_attemptWhereUniqueInput>
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
    update?: Enumerable<quiz_attemptUpdateWithWhereUniqueWithoutQuizInput>
    updateMany?: Enumerable<quiz_attemptUpdateManyWithWhereWithoutQuizInput>
    deleteMany?: Enumerable<quiz_attemptScalarWhereInput>
  }

  export type quiz_questionUpdateManyWithoutQuizInput = {
    create?: XOR<Enumerable<quiz_questionCreateWithoutQuizInput>, Enumerable<quiz_questionUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<quiz_questionCreateOrConnectWithoutQuizInput>
    upsert?: Enumerable<quiz_questionUpsertWithWhereUniqueWithoutQuizInput>
    createMany?: quiz_questionCreateManyQuizInputEnvelope
    set?: Enumerable<quiz_questionWhereUniqueInput>
    disconnect?: Enumerable<quiz_questionWhereUniqueInput>
    delete?: Enumerable<quiz_questionWhereUniqueInput>
    connect?: Enumerable<quiz_questionWhereUniqueInput>
    update?: Enumerable<quiz_questionUpdateWithWhereUniqueWithoutQuizInput>
    updateMany?: Enumerable<quiz_questionUpdateManyWithWhereWithoutQuizInput>
    deleteMany?: Enumerable<quiz_questionScalarWhereInput>
  }

  export type quiz_attemptUncheckedUpdateManyWithoutQuizInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutQuizInput>, Enumerable<quiz_attemptUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutQuizInput>
    upsert?: Enumerable<quiz_attemptUpsertWithWhereUniqueWithoutQuizInput>
    createMany?: quiz_attemptCreateManyQuizInputEnvelope
    set?: Enumerable<quiz_attemptWhereUniqueInput>
    disconnect?: Enumerable<quiz_attemptWhereUniqueInput>
    delete?: Enumerable<quiz_attemptWhereUniqueInput>
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
    update?: Enumerable<quiz_attemptUpdateWithWhereUniqueWithoutQuizInput>
    updateMany?: Enumerable<quiz_attemptUpdateManyWithWhereWithoutQuizInput>
    deleteMany?: Enumerable<quiz_attemptScalarWhereInput>
  }

  export type quiz_questionUncheckedUpdateManyWithoutQuizInput = {
    create?: XOR<Enumerable<quiz_questionCreateWithoutQuizInput>, Enumerable<quiz_questionUncheckedCreateWithoutQuizInput>>
    connectOrCreate?: Enumerable<quiz_questionCreateOrConnectWithoutQuizInput>
    upsert?: Enumerable<quiz_questionUpsertWithWhereUniqueWithoutQuizInput>
    createMany?: quiz_questionCreateManyQuizInputEnvelope
    set?: Enumerable<quiz_questionWhereUniqueInput>
    disconnect?: Enumerable<quiz_questionWhereUniqueInput>
    delete?: Enumerable<quiz_questionWhereUniqueInput>
    connect?: Enumerable<quiz_questionWhereUniqueInput>
    update?: Enumerable<quiz_questionUpdateWithWhereUniqueWithoutQuizInput>
    updateMany?: Enumerable<quiz_questionUpdateManyWithWhereWithoutQuizInput>
    deleteMany?: Enumerable<quiz_questionScalarWhereInput>
  }

  export type moduleCreateNestedOneWithoutStudent_moduleInput = {
    create?: XOR<moduleCreateWithoutStudent_moduleInput, moduleUncheckedCreateWithoutStudent_moduleInput>
    connectOrCreate?: moduleCreateOrConnectWithoutStudent_moduleInput
    connect?: moduleWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutStudent_moduleInput = {
    create?: XOR<studentCreateWithoutStudent_moduleInput, studentUncheckedCreateWithoutStudent_moduleInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_moduleInput
    connect?: studentWhereUniqueInput
  }

  export type moduleUpdateOneRequiredWithoutStudent_moduleInput = {
    create?: XOR<moduleCreateWithoutStudent_moduleInput, moduleUncheckedCreateWithoutStudent_moduleInput>
    connectOrCreate?: moduleCreateOrConnectWithoutStudent_moduleInput
    upsert?: moduleUpsertWithoutStudent_moduleInput
    connect?: moduleWhereUniqueInput
    update?: XOR<moduleUpdateWithoutStudent_moduleInput, moduleUncheckedUpdateWithoutStudent_moduleInput>
  }

  export type studentUpdateOneRequiredWithoutStudent_moduleInput = {
    create?: XOR<studentCreateWithoutStudent_moduleInput, studentUncheckedCreateWithoutStudent_moduleInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_moduleInput
    upsert?: studentUpsertWithoutStudent_moduleInput
    connect?: studentWhereUniqueInput
    update?: XOR<studentUpdateWithoutStudent_moduleInput, studentUncheckedUpdateWithoutStudent_moduleInput>
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type enrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<enrollmentCreateWithoutStudentInput>, Enumerable<enrollmentUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<enrollmentCreateOrConnectWithoutStudentInput>
    createMany?: enrollmentCreateManyStudentInputEnvelope
    connect?: Enumerable<enrollmentWhereUniqueInput>
  }

  export type quiz_attemptCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutStudentInput>, Enumerable<quiz_attemptUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutStudentInput>
    createMany?: quiz_attemptCreateManyStudentInputEnvelope
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
  }

  export type student_moduleCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<student_moduleCreateWithoutStudentInput>, Enumerable<student_moduleUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<student_moduleCreateOrConnectWithoutStudentInput>
    createMany?: student_moduleCreateManyStudentInputEnvelope
    connect?: Enumerable<student_moduleWhereUniqueInput>
  }

  export type enrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<enrollmentCreateWithoutStudentInput>, Enumerable<enrollmentUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<enrollmentCreateOrConnectWithoutStudentInput>
    createMany?: enrollmentCreateManyStudentInputEnvelope
    connect?: Enumerable<enrollmentWhereUniqueInput>
  }

  export type quiz_attemptUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutStudentInput>, Enumerable<quiz_attemptUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutStudentInput>
    createMany?: quiz_attemptCreateManyStudentInputEnvelope
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
  }

  export type student_moduleUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<student_moduleCreateWithoutStudentInput>, Enumerable<student_moduleUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<student_moduleCreateOrConnectWithoutStudentInput>
    createMany?: student_moduleCreateManyStudentInputEnvelope
    connect?: Enumerable<student_moduleWhereUniqueInput>
  }

  export type UserUpdateOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type enrollmentUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<enrollmentCreateWithoutStudentInput>, Enumerable<enrollmentUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<enrollmentCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<enrollmentUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: enrollmentCreateManyStudentInputEnvelope
    set?: Enumerable<enrollmentWhereUniqueInput>
    disconnect?: Enumerable<enrollmentWhereUniqueInput>
    delete?: Enumerable<enrollmentWhereUniqueInput>
    connect?: Enumerable<enrollmentWhereUniqueInput>
    update?: Enumerable<enrollmentUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<enrollmentUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<enrollmentScalarWhereInput>
  }

  export type quiz_attemptUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutStudentInput>, Enumerable<quiz_attemptUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<quiz_attemptUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: quiz_attemptCreateManyStudentInputEnvelope
    set?: Enumerable<quiz_attemptWhereUniqueInput>
    disconnect?: Enumerable<quiz_attemptWhereUniqueInput>
    delete?: Enumerable<quiz_attemptWhereUniqueInput>
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
    update?: Enumerable<quiz_attemptUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<quiz_attemptUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<quiz_attemptScalarWhereInput>
  }

  export type student_moduleUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<student_moduleCreateWithoutStudentInput>, Enumerable<student_moduleUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<student_moduleCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<student_moduleUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: student_moduleCreateManyStudentInputEnvelope
    set?: Enumerable<student_moduleWhereUniqueInput>
    disconnect?: Enumerable<student_moduleWhereUniqueInput>
    delete?: Enumerable<student_moduleWhereUniqueInput>
    connect?: Enumerable<student_moduleWhereUniqueInput>
    update?: Enumerable<student_moduleUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<student_moduleUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<student_moduleScalarWhereInput>
  }

  export type enrollmentUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<enrollmentCreateWithoutStudentInput>, Enumerable<enrollmentUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<enrollmentCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<enrollmentUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: enrollmentCreateManyStudentInputEnvelope
    set?: Enumerable<enrollmentWhereUniqueInput>
    disconnect?: Enumerable<enrollmentWhereUniqueInput>
    delete?: Enumerable<enrollmentWhereUniqueInput>
    connect?: Enumerable<enrollmentWhereUniqueInput>
    update?: Enumerable<enrollmentUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<enrollmentUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<enrollmentScalarWhereInput>
  }

  export type quiz_attemptUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<quiz_attemptCreateWithoutStudentInput>, Enumerable<quiz_attemptUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<quiz_attemptCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<quiz_attemptUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: quiz_attemptCreateManyStudentInputEnvelope
    set?: Enumerable<quiz_attemptWhereUniqueInput>
    disconnect?: Enumerable<quiz_attemptWhereUniqueInput>
    delete?: Enumerable<quiz_attemptWhereUniqueInput>
    connect?: Enumerable<quiz_attemptWhereUniqueInput>
    update?: Enumerable<quiz_attemptUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<quiz_attemptUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<quiz_attemptScalarWhereInput>
  }

  export type student_moduleUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<student_moduleCreateWithoutStudentInput>, Enumerable<student_moduleUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<student_moduleCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<student_moduleUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: student_moduleCreateManyStudentInputEnvelope
    set?: Enumerable<student_moduleWhereUniqueInput>
    disconnect?: Enumerable<student_moduleWhereUniqueInput>
    delete?: Enumerable<student_moduleWhereUniqueInput>
    connect?: Enumerable<student_moduleWhereUniqueInput>
    update?: Enumerable<student_moduleUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<student_moduleUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<student_moduleScalarWhereInput>
  }

  export type moduleCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<moduleCreateWithoutSubjectInput>, Enumerable<moduleUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<moduleCreateOrConnectWithoutSubjectInput>
    createMany?: moduleCreateManySubjectInputEnvelope
    connect?: Enumerable<moduleWhereUniqueInput>
  }

  export type moduleUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<moduleCreateWithoutSubjectInput>, Enumerable<moduleUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<moduleCreateOrConnectWithoutSubjectInput>
    createMany?: moduleCreateManySubjectInputEnvelope
    connect?: Enumerable<moduleWhereUniqueInput>
  }

  export type moduleUpdateManyWithoutSubjectInput = {
    create?: XOR<Enumerable<moduleCreateWithoutSubjectInput>, Enumerable<moduleUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<moduleCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<moduleUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: moduleCreateManySubjectInputEnvelope
    set?: Enumerable<moduleWhereUniqueInput>
    disconnect?: Enumerable<moduleWhereUniqueInput>
    delete?: Enumerable<moduleWhereUniqueInput>
    connect?: Enumerable<moduleWhereUniqueInput>
    update?: Enumerable<moduleUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<moduleUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<moduleScalarWhereInput>
  }

  export type moduleUncheckedUpdateManyWithoutSubjectInput = {
    create?: XOR<Enumerable<moduleCreateWithoutSubjectInput>, Enumerable<moduleUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<moduleCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<moduleUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: moduleCreateManySubjectInputEnvelope
    set?: Enumerable<moduleWhereUniqueInput>
    disconnect?: Enumerable<moduleWhereUniqueInput>
    delete?: Enumerable<moduleWhereUniqueInput>
    connect?: Enumerable<moduleWhereUniqueInput>
    update?: Enumerable<moduleUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<moduleUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<moduleScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    instructor?: instructorCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    instructor?: instructorUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserInput
    instructor?: instructorUpdateManyWithoutUserInput
    student?: studentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    instructor?: instructorUncheckedUpdateManyWithoutUserInput
    student?: studentUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    instructor?: instructorCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    instructor?: instructorUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserInput
    instructor?: instructorUpdateManyWithoutUserInput
    student?: studentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    instructor?: instructorUncheckedUpdateManyWithoutUserInput
    student?: studentUncheckedUpdateManyWithoutUserInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: Enumerable<SessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type instructorCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string | null
  }

  export type instructorUncheckedCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string | null
  }

  export type instructorCreateOrConnectWithoutUserInput = {
    where: instructorWhereUniqueInput
    create: XOR<instructorCreateWithoutUserInput, instructorUncheckedCreateWithoutUserInput>
  }

  export type instructorCreateManyUserInputEnvelope = {
    data: Enumerable<instructorCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type studentCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    enrollment?: enrollmentCreateNestedManyWithoutStudentInput
    quiz_attempt?: quiz_attemptCreateNestedManyWithoutStudentInput
    student_module?: student_moduleCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutStudentInput
    quiz_attempt?: quiz_attemptUncheckedCreateNestedManyWithoutStudentInput
    student_module?: student_moduleUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutUserInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
  }

  export type studentCreateManyUserInputEnvelope = {
    data: Enumerable<studentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    oauth_token_secret?: StringNullableFilter | string | null
    oauth_token?: StringNullableFilter | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutSessionsInput>
  }

  export type SessionScalarWhereInput = {
    AND?: Enumerable<SessionScalarWhereInput>
    OR?: Enumerable<SessionScalarWhereInput>
    NOT?: Enumerable<SessionScalarWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type instructorUpsertWithWhereUniqueWithoutUserInput = {
    where: instructorWhereUniqueInput
    update: XOR<instructorUpdateWithoutUserInput, instructorUncheckedUpdateWithoutUserInput>
    create: XOR<instructorCreateWithoutUserInput, instructorUncheckedCreateWithoutUserInput>
  }

  export type instructorUpdateWithWhereUniqueWithoutUserInput = {
    where: instructorWhereUniqueInput
    data: XOR<instructorUpdateWithoutUserInput, instructorUncheckedUpdateWithoutUserInput>
  }

  export type instructorUpdateManyWithWhereWithoutUserInput = {
    where: instructorScalarWhereInput
    data: XOR<instructorUpdateManyMutationInput, instructorUncheckedUpdateManyWithoutInstructorInput>
  }

  export type instructorScalarWhereInput = {
    AND?: Enumerable<instructorScalarWhereInput>
    OR?: Enumerable<instructorScalarWhereInput>
    NOT?: Enumerable<instructorScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: StringNullableFilter | string | null
  }

  export type studentUpsertWithWhereUniqueWithoutUserInput = {
    where: studentWhereUniqueInput
    update: XOR<studentUpdateWithoutUserInput, studentUncheckedUpdateWithoutUserInput>
    create: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
  }

  export type studentUpdateWithWhereUniqueWithoutUserInput = {
    where: studentWhereUniqueInput
    data: XOR<studentUpdateWithoutUserInput, studentUncheckedUpdateWithoutUserInput>
  }

  export type studentUpdateManyWithWhereWithoutUserInput = {
    where: studentScalarWhereInput
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyWithoutStudentInput>
  }

  export type studentScalarWhereInput = {
    AND?: Enumerable<studentScalarWhereInput>
    OR?: Enumerable<studentScalarWhereInput>
    NOT?: Enumerable<studentScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    grade_at_account_creation?: IntNullableFilter | number | null
    user_id?: StringNullableFilter | string | null
  }

  export type enrollmentCreateWithoutCourseInput = {
    id?: string
    created_at?: Date | string | null
    current_grade_level?: string | null
    student?: studentCreateNestedOneWithoutEnrollmentInput
    quiz_attempt?: quiz_attemptCreateNestedManyWithoutEnrollmentInput
  }

  export type enrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    created_at?: Date | string | null
    student_id?: string | null
    current_grade_level?: string | null
    quiz_attempt?: quiz_attemptUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type enrollmentCreateOrConnectWithoutCourseInput = {
    where: enrollmentWhereUniqueInput
    create: XOR<enrollmentCreateWithoutCourseInput, enrollmentUncheckedCreateWithoutCourseInput>
  }

  export type enrollmentCreateManyCourseInputEnvelope = {
    data: Enumerable<enrollmentCreateManyCourseInput>
    skipDuplicates?: boolean
  }

  export type enrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: enrollmentWhereUniqueInput
    update: XOR<enrollmentUpdateWithoutCourseInput, enrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<enrollmentCreateWithoutCourseInput, enrollmentUncheckedCreateWithoutCourseInput>
  }

  export type enrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: enrollmentWhereUniqueInput
    data: XOR<enrollmentUpdateWithoutCourseInput, enrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type enrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: enrollmentScalarWhereInput
    data: XOR<enrollmentUpdateManyMutationInput, enrollmentUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type enrollmentScalarWhereInput = {
    AND?: Enumerable<enrollmentScalarWhereInput>
    OR?: Enumerable<enrollmentScalarWhereInput>
    NOT?: Enumerable<enrollmentScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    student_id?: StringNullableFilter | string | null
    course_id?: StringNullableFilter | string | null
    current_grade_level?: StringNullableFilter | string | null
  }

  export type courseCreateWithoutEnrollmentInput = {
    id?: string
    created_at?: Date | string | null
    instructor_id?: string | null
    course_title: string
    updated_at?: Date | string | null
    author?: string | null
  }

  export type courseUncheckedCreateWithoutEnrollmentInput = {
    id?: string
    created_at?: Date | string | null
    instructor_id?: string | null
    course_title: string
    updated_at?: Date | string | null
    author?: string | null
  }

  export type courseCreateOrConnectWithoutEnrollmentInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutEnrollmentInput, courseUncheckedCreateWithoutEnrollmentInput>
  }

  export type studentCreateWithoutEnrollmentInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    User?: UserCreateNestedOneWithoutStudentInput
    quiz_attempt?: quiz_attemptCreateNestedManyWithoutStudentInput
    student_module?: student_moduleCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutEnrollmentInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    user_id?: string | null
    quiz_attempt?: quiz_attemptUncheckedCreateNestedManyWithoutStudentInput
    student_module?: student_moduleUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutEnrollmentInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutEnrollmentInput, studentUncheckedCreateWithoutEnrollmentInput>
  }

  export type quiz_attemptCreateWithoutEnrollmentInput = {
    id?: string
    created_at?: Date | string | null
    total_points?: number | null
    points_scored?: number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
    quiz: quizCreateNestedOneWithoutAttemptsInput
    student: studentCreateNestedOneWithoutQuiz_attemptInput
  }

  export type quiz_attemptUncheckedCreateWithoutEnrollmentInput = {
    id?: string
    created_at?: Date | string | null
    student_id: string
    quiz_id: string
    total_points?: number | null
    points_scored?: number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
  }

  export type quiz_attemptCreateOrConnectWithoutEnrollmentInput = {
    where: quiz_attemptWhereUniqueInput
    create: XOR<quiz_attemptCreateWithoutEnrollmentInput, quiz_attemptUncheckedCreateWithoutEnrollmentInput>
  }

  export type quiz_attemptCreateManyEnrollmentInputEnvelope = {
    data: Enumerable<quiz_attemptCreateManyEnrollmentInput>
    skipDuplicates?: boolean
  }

  export type courseUpsertWithoutEnrollmentInput = {
    update: XOR<courseUpdateWithoutEnrollmentInput, courseUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<courseCreateWithoutEnrollmentInput, courseUncheckedCreateWithoutEnrollmentInput>
  }

  export type courseUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_id?: NullableStringFieldUpdateOperationsInput | string | null
    course_title?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type courseUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor_id?: NullableStringFieldUpdateOperationsInput | string | null
    course_title?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentUpsertWithoutEnrollmentInput = {
    update: XOR<studentUpdateWithoutEnrollmentInput, studentUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<studentCreateWithoutEnrollmentInput, studentUncheckedCreateWithoutEnrollmentInput>
  }

  export type studentUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneWithoutStudentInput
    quiz_attempt?: quiz_attemptUpdateManyWithoutStudentInput
    student_module?: student_moduleUpdateManyWithoutStudentInput
  }

  export type studentUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    quiz_attempt?: quiz_attemptUncheckedUpdateManyWithoutStudentInput
    student_module?: student_moduleUncheckedUpdateManyWithoutStudentInput
  }

  export type quiz_attemptUpsertWithWhereUniqueWithoutEnrollmentInput = {
    where: quiz_attemptWhereUniqueInput
    update: XOR<quiz_attemptUpdateWithoutEnrollmentInput, quiz_attemptUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<quiz_attemptCreateWithoutEnrollmentInput, quiz_attemptUncheckedCreateWithoutEnrollmentInput>
  }

  export type quiz_attemptUpdateWithWhereUniqueWithoutEnrollmentInput = {
    where: quiz_attemptWhereUniqueInput
    data: XOR<quiz_attemptUpdateWithoutEnrollmentInput, quiz_attemptUncheckedUpdateWithoutEnrollmentInput>
  }

  export type quiz_attemptUpdateManyWithWhereWithoutEnrollmentInput = {
    where: quiz_attemptScalarWhereInput
    data: XOR<quiz_attemptUpdateManyMutationInput, quiz_attemptUncheckedUpdateManyWithoutQuiz_attemptInput>
  }

  export type quiz_attemptScalarWhereInput = {
    AND?: Enumerable<quiz_attemptScalarWhereInput>
    OR?: Enumerable<quiz_attemptScalarWhereInput>
    NOT?: Enumerable<quiz_attemptScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    student_id?: StringFilter | string
    quiz_id?: StringFilter | string
    total_points?: IntNullableFilter | number | null
    points_scored?: IntNullableFilter | number | null
    enroll_id?: StringNullableFilter | string | null
    answer_data?: JsonNullableFilter
    question_answered_count?: IntNullableFilter | number | null
    question_unanswered_count?: IntNullableFilter | number | null
  }

  export type UserCreateWithoutInstructorInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    student?: studentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInstructorInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstructorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
  }

  export type UserUpsertWithoutInstructorInput = {
    update: XOR<UserUpdateWithoutInstructorInput, UserUncheckedUpdateWithoutInstructorInput>
    create: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
  }

  export type UserUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    student?: studentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    student?: studentUncheckedUpdateManyWithoutUserInput
  }

  export type moduleCreateWithoutLessonInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_name: string
    subject?: subjectCreateNestedOneWithoutModuleInput
    student_module?: student_moduleCreateNestedManyWithoutModuleInput
  }

  export type moduleUncheckedCreateWithoutLessonInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_subject_id?: string | null
    module_name: string
    student_module?: student_moduleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type moduleCreateOrConnectWithoutLessonInput = {
    where: moduleWhereUniqueInput
    create: XOR<moduleCreateWithoutLessonInput, moduleUncheckedCreateWithoutLessonInput>
  }

  export type moduleUpsertWithoutLessonInput = {
    update: XOR<moduleUpdateWithoutLessonInput, moduleUncheckedUpdateWithoutLessonInput>
    create: XOR<moduleCreateWithoutLessonInput, moduleUncheckedCreateWithoutLessonInput>
  }

  export type moduleUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
    subject?: subjectUpdateOneWithoutModuleInput
    student_module?: student_moduleUpdateManyWithoutModuleInput
  }

  export type moduleUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_subject_id?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
    student_module?: student_moduleUncheckedUpdateManyWithoutModuleInput
  }

  export type subjectCreateWithoutModuleInput = {
    id?: string
    created_at?: Date | string | null
  }

  export type subjectUncheckedCreateWithoutModuleInput = {
    id?: string
    created_at?: Date | string | null
  }

  export type subjectCreateOrConnectWithoutModuleInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutModuleInput, subjectUncheckedCreateWithoutModuleInput>
  }

  export type lessonCreateWithoutModuleInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
  }

  export type lessonUncheckedCreateWithoutModuleInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
  }

  export type lessonCreateOrConnectWithoutModuleInput = {
    where: lessonWhereUniqueInput
    create: XOR<lessonCreateWithoutModuleInput, lessonUncheckedCreateWithoutModuleInput>
  }

  export type lessonCreateManyModuleInputEnvelope = {
    data: Enumerable<lessonCreateManyModuleInput>
    skipDuplicates?: boolean
  }

  export type student_moduleCreateWithoutModuleInput = {
    time_started?: Date | string
    student: studentCreateNestedOneWithoutStudent_moduleInput
  }

  export type student_moduleUncheckedCreateWithoutModuleInput = {
    student_id: string
    time_started?: Date | string
  }

  export type student_moduleCreateOrConnectWithoutModuleInput = {
    where: student_moduleWhereUniqueInput
    create: XOR<student_moduleCreateWithoutModuleInput, student_moduleUncheckedCreateWithoutModuleInput>
  }

  export type student_moduleCreateManyModuleInputEnvelope = {
    data: Enumerable<student_moduleCreateManyModuleInput>
    skipDuplicates?: boolean
  }

  export type subjectUpsertWithoutModuleInput = {
    update: XOR<subjectUpdateWithoutModuleInput, subjectUncheckedUpdateWithoutModuleInput>
    create: XOR<subjectCreateWithoutModuleInput, subjectUncheckedCreateWithoutModuleInput>
  }

  export type subjectUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subjectUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lessonUpsertWithWhereUniqueWithoutModuleInput = {
    where: lessonWhereUniqueInput
    update: XOR<lessonUpdateWithoutModuleInput, lessonUncheckedUpdateWithoutModuleInput>
    create: XOR<lessonCreateWithoutModuleInput, lessonUncheckedCreateWithoutModuleInput>
  }

  export type lessonUpdateWithWhereUniqueWithoutModuleInput = {
    where: lessonWhereUniqueInput
    data: XOR<lessonUpdateWithoutModuleInput, lessonUncheckedUpdateWithoutModuleInput>
  }

  export type lessonUpdateManyWithWhereWithoutModuleInput = {
    where: lessonScalarWhereInput
    data: XOR<lessonUpdateManyMutationInput, lessonUncheckedUpdateManyWithoutLessonInput>
  }

  export type lessonScalarWhereInput = {
    AND?: Enumerable<lessonScalarWhereInput>
    OR?: Enumerable<lessonScalarWhereInput>
    NOT?: Enumerable<lessonScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    author?: StringNullableFilter | string | null
    lesson_module?: StringNullableFilter | string | null
  }

  export type student_moduleUpsertWithWhereUniqueWithoutModuleInput = {
    where: student_moduleWhereUniqueInput
    update: XOR<student_moduleUpdateWithoutModuleInput, student_moduleUncheckedUpdateWithoutModuleInput>
    create: XOR<student_moduleCreateWithoutModuleInput, student_moduleUncheckedCreateWithoutModuleInput>
  }

  export type student_moduleUpdateWithWhereUniqueWithoutModuleInput = {
    where: student_moduleWhereUniqueInput
    data: XOR<student_moduleUpdateWithoutModuleInput, student_moduleUncheckedUpdateWithoutModuleInput>
  }

  export type student_moduleUpdateManyWithWhereWithoutModuleInput = {
    where: student_moduleScalarWhereInput
    data: XOR<student_moduleUpdateManyMutationInput, student_moduleUncheckedUpdateManyWithoutStudent_moduleInput>
  }

  export type student_moduleScalarWhereInput = {
    AND?: Enumerable<student_moduleScalarWhereInput>
    OR?: Enumerable<student_moduleScalarWhereInput>
    NOT?: Enumerable<student_moduleScalarWhereInput>
    student_id?: StringFilter | string
    module_id?: StringFilter | string
    time_started?: DateTimeFilter | Date | string
  }

  export type questionCreateWithoutQuestion_topicInput = {
    id?: string
    created_at?: Date | string | null
    difficulty?: number | null
    image_url?: string | null
    equation?: string | null
    question_text?: string | null
    answer_formula?: string | null
    updated_at?: Date | string | null
    author?: string | null
  }

  export type questionUncheckedCreateWithoutQuestion_topicInput = {
    id?: string
    created_at?: Date | string | null
    difficulty?: number | null
    image_url?: string | null
    equation?: string | null
    question_text?: string | null
    answer_formula?: string | null
    updated_at?: Date | string | null
    author?: string | null
  }

  export type questionCreateOrConnectWithoutQuestion_topicInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutQuestion_topicInput, questionUncheckedCreateWithoutQuestion_topicInput>
  }

  export type topicCreateWithoutQuestion_topicInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    question_topic_name: string
  }

  export type topicUncheckedCreateWithoutQuestion_topicInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    question_topic_name: string
  }

  export type topicCreateOrConnectWithoutQuestion_topicInput = {
    where: topicWhereUniqueInput
    create: XOR<topicCreateWithoutQuestion_topicInput, topicUncheckedCreateWithoutQuestion_topicInput>
  }

  export type questionUpsertWithoutQuestion_topicInput = {
    update: XOR<questionUpdateWithoutQuestion_topicInput, questionUncheckedUpdateWithoutQuestion_topicInput>
    create: XOR<questionCreateWithoutQuestion_topicInput, questionUncheckedCreateWithoutQuestion_topicInput>
  }

  export type questionUpdateWithoutQuestion_topicInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    equation?: NullableStringFieldUpdateOperationsInput | string | null
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    answer_formula?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type questionUncheckedUpdateWithoutQuestion_topicInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    equation?: NullableStringFieldUpdateOperationsInput | string | null
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    answer_formula?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type topicUpsertWithoutQuestion_topicInput = {
    update: XOR<topicUpdateWithoutQuestion_topicInput, topicUncheckedUpdateWithoutQuestion_topicInput>
    create: XOR<topicCreateWithoutQuestion_topicInput, topicUncheckedCreateWithoutQuestion_topicInput>
  }

  export type topicUpdateWithoutQuestion_topicInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_topic_name?: StringFieldUpdateOperationsInput | string
  }

  export type topicUncheckedUpdateWithoutQuestion_topicInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_topic_name?: StringFieldUpdateOperationsInput | string
  }

  export type question_topicCreateWithoutTopicInput = {
    id?: string
    question?: questionCreateNestedOneWithoutQuestion_topicInput
  }

  export type question_topicUncheckedCreateWithoutTopicInput = {
    id?: string
    question_id?: string | null
  }

  export type question_topicCreateOrConnectWithoutTopicInput = {
    where: question_topicWhereUniqueInput
    create: XOR<question_topicCreateWithoutTopicInput, question_topicUncheckedCreateWithoutTopicInput>
  }

  export type question_topicCreateManyTopicInputEnvelope = {
    data: Enumerable<question_topicCreateManyTopicInput>
    skipDuplicates?: boolean
  }

  export type question_topicUpsertWithWhereUniqueWithoutTopicInput = {
    where: question_topicWhereUniqueInput
    update: XOR<question_topicUpdateWithoutTopicInput, question_topicUncheckedUpdateWithoutTopicInput>
    create: XOR<question_topicCreateWithoutTopicInput, question_topicUncheckedCreateWithoutTopicInput>
  }

  export type question_topicUpdateWithWhereUniqueWithoutTopicInput = {
    where: question_topicWhereUniqueInput
    data: XOR<question_topicUpdateWithoutTopicInput, question_topicUncheckedUpdateWithoutTopicInput>
  }

  export type question_topicUpdateManyWithWhereWithoutTopicInput = {
    where: question_topicScalarWhereInput
    data: XOR<question_topicUpdateManyMutationInput, question_topicUncheckedUpdateManyWithoutQuestion_topicInput>
  }

  export type question_topicScalarWhereInput = {
    AND?: Enumerable<question_topicScalarWhereInput>
    OR?: Enumerable<question_topicScalarWhereInput>
    NOT?: Enumerable<question_topicScalarWhereInput>
    id?: StringFilter | string
    topic_id?: StringFilter | string
    question_id?: StringNullableFilter | string | null
  }

  export type question_topicCreateWithoutQuestionInput = {
    id?: string
    topic: topicCreateNestedOneWithoutQuestion_topicInput
  }

  export type question_topicUncheckedCreateWithoutQuestionInput = {
    id?: string
    topic_id: string
  }

  export type question_topicCreateOrConnectWithoutQuestionInput = {
    where: question_topicWhereUniqueInput
    create: XOR<question_topicCreateWithoutQuestionInput, question_topicUncheckedCreateWithoutQuestionInput>
  }

  export type question_topicCreateManyQuestionInputEnvelope = {
    data: Enumerable<question_topicCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type question_topicUpsertWithWhereUniqueWithoutQuestionInput = {
    where: question_topicWhereUniqueInput
    update: XOR<question_topicUpdateWithoutQuestionInput, question_topicUncheckedUpdateWithoutQuestionInput>
    create: XOR<question_topicCreateWithoutQuestionInput, question_topicUncheckedCreateWithoutQuestionInput>
  }

  export type question_topicUpdateWithWhereUniqueWithoutQuestionInput = {
    where: question_topicWhereUniqueInput
    data: XOR<question_topicUpdateWithoutQuestionInput, question_topicUncheckedUpdateWithoutQuestionInput>
  }

  export type question_topicUpdateManyWithWhereWithoutQuestionInput = {
    where: question_topicScalarWhereInput
    data: XOR<question_topicUpdateManyMutationInput, question_topicUncheckedUpdateManyWithoutQuestion_topicInput>
  }

  export type enrollmentCreateWithoutQuiz_attemptInput = {
    id?: string
    created_at?: Date | string | null
    current_grade_level?: string | null
    course?: courseCreateNestedOneWithoutEnrollmentInput
    student?: studentCreateNestedOneWithoutEnrollmentInput
  }

  export type enrollmentUncheckedCreateWithoutQuiz_attemptInput = {
    id?: string
    created_at?: Date | string | null
    student_id?: string | null
    course_id?: string | null
    current_grade_level?: string | null
  }

  export type enrollmentCreateOrConnectWithoutQuiz_attemptInput = {
    where: enrollmentWhereUniqueInput
    create: XOR<enrollmentCreateWithoutQuiz_attemptInput, enrollmentUncheckedCreateWithoutQuiz_attemptInput>
  }

  export type quizCreateWithoutAttemptsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    questions?: quiz_questionCreateNestedManyWithoutQuizInput
  }

  export type quizUncheckedCreateWithoutAttemptsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    questions?: quiz_questionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type quizCreateOrConnectWithoutAttemptsInput = {
    where: quizWhereUniqueInput
    create: XOR<quizCreateWithoutAttemptsInput, quizUncheckedCreateWithoutAttemptsInput>
  }

  export type studentCreateWithoutQuiz_attemptInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    User?: UserCreateNestedOneWithoutStudentInput
    enrollment?: enrollmentCreateNestedManyWithoutStudentInput
    student_module?: student_moduleCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutQuiz_attemptInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    user_id?: string | null
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutStudentInput
    student_module?: student_moduleUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutQuiz_attemptInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutQuiz_attemptInput, studentUncheckedCreateWithoutQuiz_attemptInput>
  }

  export type enrollmentUpsertWithoutQuiz_attemptInput = {
    update: XOR<enrollmentUpdateWithoutQuiz_attemptInput, enrollmentUncheckedUpdateWithoutQuiz_attemptInput>
    create: XOR<enrollmentCreateWithoutQuiz_attemptInput, enrollmentUncheckedCreateWithoutQuiz_attemptInput>
  }

  export type enrollmentUpdateWithoutQuiz_attemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
    course?: courseUpdateOneWithoutEnrollmentInput
    student?: studentUpdateOneWithoutEnrollmentInput
  }

  export type enrollmentUncheckedUpdateWithoutQuiz_attemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quizUpsertWithoutAttemptsInput = {
    update: XOR<quizUpdateWithoutAttemptsInput, quizUncheckedUpdateWithoutAttemptsInput>
    create: XOR<quizCreateWithoutAttemptsInput, quizUncheckedCreateWithoutAttemptsInput>
  }

  export type quizUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: quiz_questionUpdateManyWithoutQuizInput
  }

  export type quizUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: quiz_questionUncheckedUpdateManyWithoutQuizInput
  }

  export type studentUpsertWithoutQuiz_attemptInput = {
    update: XOR<studentUpdateWithoutQuiz_attemptInput, studentUncheckedUpdateWithoutQuiz_attemptInput>
    create: XOR<studentCreateWithoutQuiz_attemptInput, studentUncheckedCreateWithoutQuiz_attemptInput>
  }

  export type studentUpdateWithoutQuiz_attemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneWithoutStudentInput
    enrollment?: enrollmentUpdateManyWithoutStudentInput
    student_module?: student_moduleUpdateManyWithoutStudentInput
  }

  export type studentUncheckedUpdateWithoutQuiz_attemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUncheckedUpdateManyWithoutStudentInput
    student_module?: student_moduleUncheckedUpdateManyWithoutStudentInput
  }

  export type quizCreateWithoutQuestionsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    attempts?: quiz_attemptCreateNestedManyWithoutQuizInput
  }

  export type quizUncheckedCreateWithoutQuestionsInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    attempts?: quiz_attemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type quizCreateOrConnectWithoutQuestionsInput = {
    where: quizWhereUniqueInput
    create: XOR<quizCreateWithoutQuestionsInput, quizUncheckedCreateWithoutQuestionsInput>
  }

  export type quizUpsertWithoutQuestionsInput = {
    update: XOR<quizUpdateWithoutQuestionsInput, quizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<quizCreateWithoutQuestionsInput, quizUncheckedCreateWithoutQuestionsInput>
  }

  export type quizUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: quiz_attemptUpdateManyWithoutQuizInput
  }

  export type quizUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: quiz_attemptUncheckedUpdateManyWithoutQuizInput
  }

  export type quiz_attemptCreateWithoutQuizInput = {
    id?: string
    created_at?: Date | string | null
    total_points?: number | null
    points_scored?: number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
    enrollment?: enrollmentCreateNestedOneWithoutQuiz_attemptInput
    student: studentCreateNestedOneWithoutQuiz_attemptInput
  }

  export type quiz_attemptUncheckedCreateWithoutQuizInput = {
    id?: string
    created_at?: Date | string | null
    student_id: string
    total_points?: number | null
    points_scored?: number | null
    enroll_id?: string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
  }

  export type quiz_attemptCreateOrConnectWithoutQuizInput = {
    where: quiz_attemptWhereUniqueInput
    create: XOR<quiz_attemptCreateWithoutQuizInput, quiz_attemptUncheckedCreateWithoutQuizInput>
  }

  export type quiz_attemptCreateManyQuizInputEnvelope = {
    data: Enumerable<quiz_attemptCreateManyQuizInput>
    skipDuplicates?: boolean
  }

  export type quiz_questionCreateWithoutQuizInput = {
    created_at?: Date | string | null
    question_id: string
    question_number?: number | null
  }

  export type quiz_questionUncheckedCreateWithoutQuizInput = {
    created_at?: Date | string | null
    question_id: string
    question_number?: number | null
  }

  export type quiz_questionCreateOrConnectWithoutQuizInput = {
    where: quiz_questionWhereUniqueInput
    create: XOR<quiz_questionCreateWithoutQuizInput, quiz_questionUncheckedCreateWithoutQuizInput>
  }

  export type quiz_questionCreateManyQuizInputEnvelope = {
    data: Enumerable<quiz_questionCreateManyQuizInput>
    skipDuplicates?: boolean
  }

  export type quiz_attemptUpsertWithWhereUniqueWithoutQuizInput = {
    where: quiz_attemptWhereUniqueInput
    update: XOR<quiz_attemptUpdateWithoutQuizInput, quiz_attemptUncheckedUpdateWithoutQuizInput>
    create: XOR<quiz_attemptCreateWithoutQuizInput, quiz_attemptUncheckedCreateWithoutQuizInput>
  }

  export type quiz_attemptUpdateWithWhereUniqueWithoutQuizInput = {
    where: quiz_attemptWhereUniqueInput
    data: XOR<quiz_attemptUpdateWithoutQuizInput, quiz_attemptUncheckedUpdateWithoutQuizInput>
  }

  export type quiz_attemptUpdateManyWithWhereWithoutQuizInput = {
    where: quiz_attemptScalarWhereInput
    data: XOR<quiz_attemptUpdateManyMutationInput, quiz_attemptUncheckedUpdateManyWithoutAttemptsInput>
  }

  export type quiz_questionUpsertWithWhereUniqueWithoutQuizInput = {
    where: quiz_questionWhereUniqueInput
    update: XOR<quiz_questionUpdateWithoutQuizInput, quiz_questionUncheckedUpdateWithoutQuizInput>
    create: XOR<quiz_questionCreateWithoutQuizInput, quiz_questionUncheckedCreateWithoutQuizInput>
  }

  export type quiz_questionUpdateWithWhereUniqueWithoutQuizInput = {
    where: quiz_questionWhereUniqueInput
    data: XOR<quiz_questionUpdateWithoutQuizInput, quiz_questionUncheckedUpdateWithoutQuizInput>
  }

  export type quiz_questionUpdateManyWithWhereWithoutQuizInput = {
    where: quiz_questionScalarWhereInput
    data: XOR<quiz_questionUpdateManyMutationInput, quiz_questionUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type quiz_questionScalarWhereInput = {
    AND?: Enumerable<quiz_questionScalarWhereInput>
    OR?: Enumerable<quiz_questionScalarWhereInput>
    NOT?: Enumerable<quiz_questionScalarWhereInput>
    created_at?: DateTimeNullableFilter | Date | string | null
    quiz_id?: StringFilter | string
    question_id?: StringFilter | string
    question_number?: IntNullableFilter | number | null
  }

  export type moduleCreateWithoutStudent_moduleInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_name: string
    subject?: subjectCreateNestedOneWithoutModuleInput
    lesson?: lessonCreateNestedManyWithoutModuleInput
  }

  export type moduleUncheckedCreateWithoutStudent_moduleInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_subject_id?: string | null
    module_name: string
    lesson?: lessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type moduleCreateOrConnectWithoutStudent_moduleInput = {
    where: moduleWhereUniqueInput
    create: XOR<moduleCreateWithoutStudent_moduleInput, moduleUncheckedCreateWithoutStudent_moduleInput>
  }

  export type studentCreateWithoutStudent_moduleInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    User?: UserCreateNestedOneWithoutStudentInput
    enrollment?: enrollmentCreateNestedManyWithoutStudentInput
    quiz_attempt?: quiz_attemptCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutStudent_moduleInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
    user_id?: string | null
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutStudentInput
    quiz_attempt?: quiz_attemptUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutStudent_moduleInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutStudent_moduleInput, studentUncheckedCreateWithoutStudent_moduleInput>
  }

  export type moduleUpsertWithoutStudent_moduleInput = {
    update: XOR<moduleUpdateWithoutStudent_moduleInput, moduleUncheckedUpdateWithoutStudent_moduleInput>
    create: XOR<moduleCreateWithoutStudent_moduleInput, moduleUncheckedCreateWithoutStudent_moduleInput>
  }

  export type moduleUpdateWithoutStudent_moduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
    subject?: subjectUpdateOneWithoutModuleInput
    lesson?: lessonUpdateManyWithoutModuleInput
  }

  export type moduleUncheckedUpdateWithoutStudent_moduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_subject_id?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
    lesson?: lessonUncheckedUpdateManyWithoutModuleInput
  }

  export type studentUpsertWithoutStudent_moduleInput = {
    update: XOR<studentUpdateWithoutStudent_moduleInput, studentUncheckedUpdateWithoutStudent_moduleInput>
    create: XOR<studentCreateWithoutStudent_moduleInput, studentUncheckedCreateWithoutStudent_moduleInput>
  }

  export type studentUpdateWithoutStudent_moduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneWithoutStudentInput
    enrollment?: enrollmentUpdateManyWithoutStudentInput
    quiz_attempt?: quiz_attemptUpdateManyWithoutStudentInput
  }

  export type studentUncheckedUpdateWithoutStudent_moduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUncheckedUpdateManyWithoutStudentInput
    quiz_attempt?: quiz_attemptUncheckedUpdateManyWithoutStudentInput
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    instructor?: instructorCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    role?: Role
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    instructor?: instructorUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type enrollmentCreateWithoutStudentInput = {
    id?: string
    created_at?: Date | string | null
    current_grade_level?: string | null
    course?: courseCreateNestedOneWithoutEnrollmentInput
    quiz_attempt?: quiz_attemptCreateNestedManyWithoutEnrollmentInput
  }

  export type enrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    created_at?: Date | string | null
    course_id?: string | null
    current_grade_level?: string | null
    quiz_attempt?: quiz_attemptUncheckedCreateNestedManyWithoutEnrollmentInput
  }

  export type enrollmentCreateOrConnectWithoutStudentInput = {
    where: enrollmentWhereUniqueInput
    create: XOR<enrollmentCreateWithoutStudentInput, enrollmentUncheckedCreateWithoutStudentInput>
  }

  export type enrollmentCreateManyStudentInputEnvelope = {
    data: Enumerable<enrollmentCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type quiz_attemptCreateWithoutStudentInput = {
    id?: string
    created_at?: Date | string | null
    total_points?: number | null
    points_scored?: number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
    enrollment?: enrollmentCreateNestedOneWithoutQuiz_attemptInput
    quiz: quizCreateNestedOneWithoutAttemptsInput
  }

  export type quiz_attemptUncheckedCreateWithoutStudentInput = {
    id?: string
    created_at?: Date | string | null
    quiz_id: string
    total_points?: number | null
    points_scored?: number | null
    enroll_id?: string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
  }

  export type quiz_attemptCreateOrConnectWithoutStudentInput = {
    where: quiz_attemptWhereUniqueInput
    create: XOR<quiz_attemptCreateWithoutStudentInput, quiz_attemptUncheckedCreateWithoutStudentInput>
  }

  export type quiz_attemptCreateManyStudentInputEnvelope = {
    data: Enumerable<quiz_attemptCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type student_moduleCreateWithoutStudentInput = {
    time_started?: Date | string
    module: moduleCreateNestedOneWithoutStudent_moduleInput
  }

  export type student_moduleUncheckedCreateWithoutStudentInput = {
    module_id: string
    time_started?: Date | string
  }

  export type student_moduleCreateOrConnectWithoutStudentInput = {
    where: student_moduleWhereUniqueInput
    create: XOR<student_moduleCreateWithoutStudentInput, student_moduleUncheckedCreateWithoutStudentInput>
  }

  export type student_moduleCreateManyStudentInputEnvelope = {
    data: Enumerable<student_moduleCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserInput
    sessions?: SessionUpdateManyWithoutUserInput
    instructor?: instructorUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserInput
    sessions?: SessionUncheckedUpdateManyWithoutUserInput
    instructor?: instructorUncheckedUpdateManyWithoutUserInput
  }

  export type enrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: enrollmentWhereUniqueInput
    update: XOR<enrollmentUpdateWithoutStudentInput, enrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<enrollmentCreateWithoutStudentInput, enrollmentUncheckedCreateWithoutStudentInput>
  }

  export type enrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: enrollmentWhereUniqueInput
    data: XOR<enrollmentUpdateWithoutStudentInput, enrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type enrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: enrollmentScalarWhereInput
    data: XOR<enrollmentUpdateManyMutationInput, enrollmentUncheckedUpdateManyWithoutEnrollmentInput>
  }

  export type quiz_attemptUpsertWithWhereUniqueWithoutStudentInput = {
    where: quiz_attemptWhereUniqueInput
    update: XOR<quiz_attemptUpdateWithoutStudentInput, quiz_attemptUncheckedUpdateWithoutStudentInput>
    create: XOR<quiz_attemptCreateWithoutStudentInput, quiz_attemptUncheckedCreateWithoutStudentInput>
  }

  export type quiz_attemptUpdateWithWhereUniqueWithoutStudentInput = {
    where: quiz_attemptWhereUniqueInput
    data: XOR<quiz_attemptUpdateWithoutStudentInput, quiz_attemptUncheckedUpdateWithoutStudentInput>
  }

  export type quiz_attemptUpdateManyWithWhereWithoutStudentInput = {
    where: quiz_attemptScalarWhereInput
    data: XOR<quiz_attemptUpdateManyMutationInput, quiz_attemptUncheckedUpdateManyWithoutQuiz_attemptInput>
  }

  export type student_moduleUpsertWithWhereUniqueWithoutStudentInput = {
    where: student_moduleWhereUniqueInput
    update: XOR<student_moduleUpdateWithoutStudentInput, student_moduleUncheckedUpdateWithoutStudentInput>
    create: XOR<student_moduleCreateWithoutStudentInput, student_moduleUncheckedCreateWithoutStudentInput>
  }

  export type student_moduleUpdateWithWhereUniqueWithoutStudentInput = {
    where: student_moduleWhereUniqueInput
    data: XOR<student_moduleUpdateWithoutStudentInput, student_moduleUncheckedUpdateWithoutStudentInput>
  }

  export type student_moduleUpdateManyWithWhereWithoutStudentInput = {
    where: student_moduleScalarWhereInput
    data: XOR<student_moduleUpdateManyMutationInput, student_moduleUncheckedUpdateManyWithoutStudent_moduleInput>
  }

  export type moduleCreateWithoutSubjectInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_name: string
    lesson?: lessonCreateNestedManyWithoutModuleInput
    student_module?: student_moduleCreateNestedManyWithoutModuleInput
  }

  export type moduleUncheckedCreateWithoutSubjectInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_name: string
    lesson?: lessonUncheckedCreateNestedManyWithoutModuleInput
    student_module?: student_moduleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type moduleCreateOrConnectWithoutSubjectInput = {
    where: moduleWhereUniqueInput
    create: XOR<moduleCreateWithoutSubjectInput, moduleUncheckedCreateWithoutSubjectInput>
  }

  export type moduleCreateManySubjectInputEnvelope = {
    data: Enumerable<moduleCreateManySubjectInput>
    skipDuplicates?: boolean
  }

  export type moduleUpsertWithWhereUniqueWithoutSubjectInput = {
    where: moduleWhereUniqueInput
    update: XOR<moduleUpdateWithoutSubjectInput, moduleUncheckedUpdateWithoutSubjectInput>
    create: XOR<moduleCreateWithoutSubjectInput, moduleUncheckedCreateWithoutSubjectInput>
  }

  export type moduleUpdateWithWhereUniqueWithoutSubjectInput = {
    where: moduleWhereUniqueInput
    data: XOR<moduleUpdateWithoutSubjectInput, moduleUncheckedUpdateWithoutSubjectInput>
  }

  export type moduleUpdateManyWithWhereWithoutSubjectInput = {
    where: moduleScalarWhereInput
    data: XOR<moduleUpdateManyMutationInput, moduleUncheckedUpdateManyWithoutModuleInput>
  }

  export type moduleScalarWhereInput = {
    AND?: Enumerable<moduleScalarWhereInput>
    OR?: Enumerable<moduleScalarWhereInput>
    NOT?: Enumerable<moduleScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    author?: StringNullableFilter | string | null
    module_subject_id?: StringNullableFilter | string | null
    module_name?: StringFilter | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    oauth_token_secret?: string | null
    oauth_token?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type instructorCreateManyUserInput = {
    id?: string
    created_at?: Date | string | null
  }

  export type studentCreateManyUserInput = {
    id?: string
    created_at?: Date | string | null
    grade_at_account_creation?: number | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token_secret?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type instructorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type instructorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type instructorUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    enrollment?: enrollmentUpdateManyWithoutStudentInput
    quiz_attempt?: quiz_attemptUpdateManyWithoutStudentInput
    student_module?: student_moduleUpdateManyWithoutStudentInput
  }

  export type studentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
    enrollment?: enrollmentUncheckedUpdateManyWithoutStudentInput
    quiz_attempt?: quiz_attemptUncheckedUpdateManyWithoutStudentInput
    student_module?: student_moduleUncheckedUpdateManyWithoutStudentInput
  }

  export type studentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade_at_account_creation?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type enrollmentCreateManyCourseInput = {
    id?: string
    created_at?: Date | string | null
    student_id?: string | null
    current_grade_level?: string | null
  }

  export type enrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
    student?: studentUpdateOneWithoutEnrollmentInput
    quiz_attempt?: quiz_attemptUpdateManyWithoutEnrollmentInput
  }

  export type enrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
    quiz_attempt?: quiz_attemptUncheckedUpdateManyWithoutEnrollmentInput
  }

  export type enrollmentUncheckedUpdateManyWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quiz_attemptCreateManyEnrollmentInput = {
    id?: string
    created_at?: Date | string | null
    student_id: string
    quiz_id: string
    total_points?: number | null
    points_scored?: number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
  }

  export type quiz_attemptUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
    quiz?: quizUpdateOneRequiredWithoutAttemptsInput
    student?: studentUpdateOneRequiredWithoutQuiz_attemptInput
  }

  export type quiz_attemptUncheckedUpdateWithoutEnrollmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_attemptUncheckedUpdateManyWithoutQuiz_attemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type lessonCreateManyModuleInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
  }

  export type student_moduleCreateManyModuleInput = {
    student_id: string
    time_started?: Date | string
  }

  export type lessonUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lessonUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lessonUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_moduleUpdateWithoutModuleInput = {
    time_started?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: studentUpdateOneRequiredWithoutStudent_moduleInput
  }

  export type student_moduleUncheckedUpdateWithoutModuleInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    time_started?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_moduleUncheckedUpdateManyWithoutStudent_moduleInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    time_started?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_topicCreateManyTopicInput = {
    id?: string
    question_id?: string | null
  }

  export type question_topicUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: questionUpdateOneWithoutQuestion_topicInput
  }

  export type question_topicUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type question_topicUncheckedUpdateManyWithoutQuestion_topicInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type question_topicCreateManyQuestionInput = {
    id?: string
    topic_id: string
  }

  export type question_topicUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: topicUpdateOneRequiredWithoutQuestion_topicInput
  }

  export type question_topicUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic_id?: StringFieldUpdateOperationsInput | string
  }

  export type quiz_attemptCreateManyQuizInput = {
    id?: string
    created_at?: Date | string | null
    student_id: string
    total_points?: number | null
    points_scored?: number | null
    enroll_id?: string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
  }

  export type quiz_questionCreateManyQuizInput = {
    created_at?: Date | string | null
    question_id: string
    question_number?: number | null
  }

  export type quiz_attemptUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
    enrollment?: enrollmentUpdateOneWithoutQuiz_attemptInput
    student?: studentUpdateOneRequiredWithoutQuiz_attemptInput
  }

  export type quiz_attemptUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: StringFieldUpdateOperationsInput | string
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    enroll_id?: NullableStringFieldUpdateOperationsInput | string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_attemptUncheckedUpdateManyWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_id?: StringFieldUpdateOperationsInput | string
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    enroll_id?: NullableStringFieldUpdateOperationsInput | string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_questionUpdateWithoutQuizInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_id?: StringFieldUpdateOperationsInput | string
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_questionUncheckedUpdateWithoutQuizInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_id?: StringFieldUpdateOperationsInput | string
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quiz_questionUncheckedUpdateManyWithoutQuestionsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_id?: StringFieldUpdateOperationsInput | string
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type enrollmentCreateManyStudentInput = {
    id?: string
    created_at?: Date | string | null
    course_id?: string | null
    current_grade_level?: string | null
  }

  export type quiz_attemptCreateManyStudentInput = {
    id?: string
    created_at?: Date | string | null
    quiz_id: string
    total_points?: number | null
    points_scored?: number | null
    enroll_id?: string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: number | null
    question_unanswered_count?: number | null
  }

  export type student_moduleCreateManyStudentInput = {
    module_id: string
    time_started?: Date | string
  }

  export type enrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
    course?: courseUpdateOneWithoutEnrollmentInput
    quiz_attempt?: quiz_attemptUpdateManyWithoutEnrollmentInput
  }

  export type enrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_grade_level?: NullableStringFieldUpdateOperationsInput | string | null
    quiz_attempt?: quiz_attemptUncheckedUpdateManyWithoutEnrollmentInput
  }

  export type quiz_attemptUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
    enrollment?: enrollmentUpdateOneWithoutQuiz_attemptInput
    quiz?: quizUpdateOneRequiredWithoutAttemptsInput
  }

  export type quiz_attemptUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz_id?: StringFieldUpdateOperationsInput | string
    total_points?: NullableIntFieldUpdateOperationsInput | number | null
    points_scored?: NullableIntFieldUpdateOperationsInput | number | null
    enroll_id?: NullableStringFieldUpdateOperationsInput | string | null
    answer_data?: NullableJsonNullValueInput | InputJsonValue
    question_answered_count?: NullableIntFieldUpdateOperationsInput | number | null
    question_unanswered_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type student_moduleUpdateWithoutStudentInput = {
    time_started?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: moduleUpdateOneRequiredWithoutStudent_moduleInput
  }

  export type student_moduleUncheckedUpdateWithoutStudentInput = {
    module_id?: StringFieldUpdateOperationsInput | string
    time_started?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type moduleCreateManySubjectInput = {
    id?: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    author?: string | null
    module_name: string
  }

  export type moduleUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
    lesson?: lessonUpdateManyWithoutModuleInput
    student_module?: student_moduleUpdateManyWithoutModuleInput
  }

  export type moduleUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
    lesson?: lessonUncheckedUpdateManyWithoutModuleInput
    student_module?: student_moduleUncheckedUpdateManyWithoutModuleInput
  }

  export type moduleUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    module_name?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}